{"ast":null,"code":"import swal from 'sweetalert2';\nimport { InjectionToken, ChangeDetectionStrategy, Component, EventEmitter, Inject, Input, Output, ComponentFactoryResolver, Directive, HostListener, ViewContainerRef, TemplateRef, ApplicationRef, Host, Injector, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Represents an object of targets for <swal> partials (use with *swalPartial directive).\n * We must use thunks to access the swal.* functions listed below, because they get created after the first modal is\n * shown, so this object lets us reference those functions safely and in a statically-typed manner.\n */\nclass SwalPartialTargets {\n  constructor() {\n    this.title = () => swal.getTitle();\n    this.content = () => swal.getContent();\n    /**\n     * @deprecated Will be removed in the next major version, please use {\\@link SwalPartialTargets#actions} instead.\n     */\n    this.buttonsWrapper = () => swal.getButtonsWrapper();\n    this.actions = () => swal.getActions();\n    this.confirmButton = () => swal.getConfirmButton();\n    this.cancelButton = () => swal.getCancelButton();\n    this.footer = () => swal.getFooter();\n  }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nconst SwalDefaults = new InjectionToken('SwalDefaults');\n/**\n * @param {?=} options\n * @return {?}\n */\nfunction swalDefaultsProvider(options = {}) {\n  return {\n    provide: SwalDefaults,\n    useValue: options\n  };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * <swal> component. See the README.md for usage.\n *\n * It contains a bunch of \\@Inputs that have a perfect 1:1 mapping with SweetAlert2 options.\n * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled\n * to SweetAlert2, but also is type-safe.\n *\n * /!\\ Some SweetAlert options aren't \\@Inputs but \\@Outputs: onBeforeOpen, onOpen, and onClose (without \"on*\" prefix).\n *     However, preConfirm and inputValidtor are still \\@Inputs because there are not event handlers, there can't be\n *     multiple listeners and we need the Promise they must return.\n *\n * /!\\ You can notice that the SweetAlert2 `useRejections` and `expectRejections` are the only one to not have\n *     an \\@Input(). That's because they are deprecated and not using the default value of these parameters leads to\n *     clunky control flow. They are supported (use [options]=\"{}\"), but please don't use them.\n */\nclass SwalComponent {\n  /**\n   * @param {?} defaultSwalOptions\n   */\n  constructor(defaultSwalOptions) {\n    this.defaultSwalOptions = defaultSwalOptions;\n    /**\n     * Emits a BeforeOpenEvent when the modal DOM element has been created.\n     * Useful to perform DOM mutations before the modal is shown.\n     */\n    this.beforeOpen = new EventEmitter();\n    /**\n     * Emits an OpenEvent when the modal is shown.\n     */\n    this.open = new EventEmitter();\n    /**\n     * Emits a CloseEvent when modal get closed.\n     */\n    this.close = new EventEmitter();\n    /**\n     * Emits when the user clicks \"Confirm\".\n     * Bears a value when using \"input\", resolved \"preConfirm\", etc.\n     *\n     * Example:\n     *     public handleConfirm(email: string): void {\n     *         // ... save user email\n     *     }\n     */\n    this.confirm = new EventEmitter();\n    /**\n     * Emits when the user clicks \"Cancel\" (or dismisses the modal by any other way).\n     * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the\n     * value of a rejected \"preConfirm\".\n     *\n     * Example:\n     *     public handleCancel(reason: string): void {\n     *         // reason can be 'cancel', 'overlay', 'close', and 'timer'\n     *         // ... do something\n     *     }\n     */\n    this.cancel = new EventEmitter();\n    this.nativeSwal = swal;\n    this.isCurrentlyShown = false;\n    this.touchedProps = new Set();\n    this.markTouched = this.touchedProps.add.bind(this.touchedProps);\n    //=> Force `this` scope of show() on this component\n    //   Useful for doing things like (click)=\"mySwal.show()\".\n    this.show = this.show.bind(this);\n  }\n  /**\n   * An object of SweetAlert2 native options, useful if:\n   *  - you don't want to use the \\@Inputs for practical/philosophical reasons ;\n   *  - there are missing \\@Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.\n   *\n   * /!\\ Be aware that the options defined in this object will override the \\@Inputs of the same name.\n   * @param {?} options\n   * @return {?}\n   */\n  set options(options) {\n    Object.assign(this, options);\n    Object.keys(options).forEach(this.markTouched);\n  }\n  /**\n   * @return {?}\n   */\n  get options() {\n    const /** @type {?} */options = {};\n    //=> We will compute the options object based on the option keys that are known to have changed.\n    // That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially avoiding\n    // side effects.\n    this.touchedProps.forEach(prop => {\n      options[prop] = /** @type {?} */this[prop];\n    });\n    return options;\n  }\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n  ngOnChanges(changes) {\n    Object.keys(changes).filter(prop => prop !== 'options').forEach(this.markTouched);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnDestroy() {\n    if (this.isCurrentlyShown) {\n      swal.close();\n    }\n  }\n  /**\n   * Shows the SweetAlert.\n   *\n   * Returns the SweetAlert2 promise for convenience and use in code behind templates.\n   * Otherwise, (confirm)=\"myHandler($event)\" and (cancel)=\"myHandler($event)\" can be used in templates.\n   * @return {?}\n   */\n  show() {\n    //=> Build the SweetAlert2 options\n    const /** @type {?} */options = Object.assign({}, this.defaultSwalOptions, this.options, {\n      onBeforeOpen: modalElement => {\n        this.beforeOpen.emit({\n          modalElement\n        });\n      },\n      onOpen: modalElement => {\n        this.isCurrentlyShown = true;\n        this.open.emit({\n          modalElement\n        });\n      },\n      onClose: modalElement => {\n        this.isCurrentlyShown = false;\n        this.close.emit({\n          modalElement\n        });\n      }\n    });\n    //=> Show the Swal!\n    const /** @type {?} */promise = swal(options);\n    //=> Handle (confirm) and (cancel) @Outputs\n    // tslint:disable-next-line:no-string-literal\n    const /** @type {?} */useRejections = /** @type {?} */options.useRejections;\n    promise.then(result => {\n      if (useRejections) {\n        this.confirm.emit(result);\n      } else if ('value' in result) {\n        this.confirm.emit(result.value);\n      } else {\n        this.cancel.emit(result.dismiss);\n      }\n    }, err => {\n      if (useRejections) {\n        this.cancel.emit(err);\n      }\n    });\n    //=> Return the unaltered promise\n    return promise;\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * [swal] directive. It takes a value that defines the Sweet Alert and can be of three types:\n *\n * 1) A simple array of two or three strings defining [title, text, type] - the type being optional, ex:\n *\n *    <button [swal]=\"['Title', 'Text']\">Click me</button>\n *\n * 2) A native SweetAlert2 options object, ex:\n *\n *    <button [swal]=\"{ title: 'Title', text: 'Text' }\">Click me</button>\n *\n * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:\n *\n *    <button [swal]=\"mySwal\">Click me</button>\n *    <swal #mySwal title=\"Title\" text=\"Text\"></swal>\n */\nclass SwalDirective {\n  /**\n   * @param {?} viewContainerRef\n   * @param {?} resolver\n   */\n  constructor(viewContainerRef, resolver) {\n    this.viewContainerRef = viewContainerRef;\n    this.resolver = resolver;\n    /**\n     * Emits when the user clicks \"Confirm\".\n     * Bears a value when using \"input\", resolved \"preConfirm\", etc.\n     *\n     * Example:\n     *     public handleConfirm(email: string): void {\n     *         // ... save user email\n     *     }\n     */\n    this.confirm = new EventEmitter();\n    /**\n     * Emits when the user clicks \"Cancel\" (or dismisses the modal by any other way).\n     * By default, it will emit a string representing the reason for which the SweetAlert has been closed, or the\n     * value of a rejected \"preConfirm\".\n     *\n     * Example:\n     *     public handleCancel(reason: string): void {\n     *         // reason can be 'cancel', 'overlay', 'close', and 'timer'\n     *         // ... do something\n     *     }\n     */\n    this.cancel = new EventEmitter();\n  }\n  /**\n   * SweetAlert2 options or a SwalComponent instance.\n   * See the class doc block for more informations.\n   * @param {?} options\n   * @return {?}\n   */\n  set swal(options) {\n    if (options instanceof SwalComponent) {\n      this.swalInstance = options;\n    } else if (Array.isArray(options)) {\n      this.swalOptions = swal.argsToParams(options);\n    } else {\n      this.swalOptions = options;\n    }\n  }\n  /**\n   * OnInit lifecycle handler.\n   * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm) and\n   * (cancel) outputs to reemit on the directive.\n   * @return {?}\n   */\n  ngOnInit() {\n    if (!this.swalInstance) {\n      const /** @type {?} */factory = this.resolver.resolveComponentFactory(SwalComponent);\n      this.swalRef = this.viewContainerRef.createComponent(factory);\n      this.swalInstance = this.swalRef.instance;\n    }\n  }\n  /**\n   * OnDestroy lifecycle handler.\n   * Destroys the dynamically-created SwalComponent and unsubscribes from that component's (confirm) and (cancel).\n   * @return {?}\n   */\n  ngOnDestroy() {\n    if (this.swalRef) {\n      this.swalRef.destroy();\n    }\n  }\n  /**\n   * Click handler.\n   * The directive listens for onclick events on its host element.\n   * When this happens, it shows the <swal> attached to this directive.\n   * @param {?} event\n   * @return {?}\n   */\n  onHostClicked(event) {\n    event.preventDefault();\n    event.stopImmediatePropagation();\n    event.stopPropagation();\n    if (this.swalOptions) {\n      this.swalInstance.options = this.swalOptions;\n    }\n    const /** @type {?} */confirmSub = this.swalInstance.confirm.asObservable().subscribe(v => this.confirm.emit(v));\n    const /** @type {?} */cancelSub = this.swalInstance.cancel.asObservable().subscribe(v => this.cancel.emit(v));\n    this.swalInstance.show().then(unsubscribe);\n    /**\n     * @return {?}\n     */\n    function unsubscribe() {\n      confirmSub.unsubscribe();\n      cancelSub.unsubscribe();\n    }\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@internal\n * Holds a consumer's Angular template and displays it on a Sweet Alert.\n * See SwalPartialDirective for info about the covered feature.\n */\nclass SwalPartialComponent {}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * A structural directive that lets you use Angular templates inside of Sweet Alerts.\n * There are different targetable zones in a Sweet Alert: title, content, confirmButton, cancelButton, buttonsWrapper.\n * The default target is the content zone.\n *\n * Usage in your component's TypeScript code-behind (if you use another target than \"content\"):\n *\n *     \\@Component({ ... })\n *     export class MyComponent {\n *         public constructor(public readonly swalTargets: SwalPartialTargets) {\n *         }\n *     }\n *\n * Usage in the template:\n *\n *     <swal title=\"Fill the form\" (confirm)=\"confirmHandler()\">\n *         <!-- This form will be displayed as the alert main content\n *              Targets the alert's main content zone by default -->\n *         <form *swalPartial [formControl]=\"myForm\">\n *             ...\n *         </form>\n *\n *         <!-- This targets the confirm button's inner content\n *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->\n *         <ng-container *swalPartial=\"swalTargets.confirmButton\">\n *              Send ({{ secondsLeft }} seconds left)\n *         </ng-container>\n *     <swal>\n */\nclass SwalPartialDirective {\n  /**\n   * @param {?} resolver\n   * @param {?} injector\n   * @param {?} app\n   * @param {?} templateRef\n   * @param {?} swalTargets\n   * @param {?} swalComponent\n   */\n  constructor(resolver, injector, app, templateRef, swalTargets, swalComponent) {\n    this.resolver = resolver;\n    this.injector = injector;\n    this.app = app;\n    this.templateRef = templateRef;\n    this.swalTargets = swalTargets;\n    this.swalComponent = swalComponent;\n  }\n  /**\n   * Subscribes to the the Sweet Alert appearance/disappearance to create/destroy the SwalPartialComponent that will\n   * receive the consumer's template.\n   * @return {?}\n   */\n  ngOnInit() {\n    this.beforeOpenSubscription = this.swalComponent.beforeOpen.asObservable().subscribe(() => {\n      //=> Create the SwalPartialComponent on the target DOM node in the Sweet Alert\n      const /** @type {?} */targetEl = this.swalPartial ? this.swalPartial() : this.swalTargets.content();\n      const /** @type {?} */factory = this.resolver.resolveComponentFactory(SwalPartialComponent);\n      this.partialRef = factory.create(this.injector, [], targetEl);\n      //=> Apply the consumer's template on the component\n      this.partialRef.instance.template = this.templateRef;\n      //=> Make the Angular app aware of that detached view so change detection works\n      this.app.attachView(this.partialRef.hostView);\n    });\n    this.closeSubscription = this.swalComponent.close.asObservable().subscribe(() => {\n      //=> Detach the partial component from the app and destroy it\n      this.app.detachView(this.partialRef.hostView);\n      this.partialRef.destroy();\n    });\n  }\n  /**\n   * Unsubscribes from the Sweet Alert appearance/disappearance.\n   * @return {?}\n   */\n  ngOnDestroy() {\n    this.beforeOpenSubscription.unsubscribe();\n    this.closeSubscription.unsubscribe();\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nclass SweetAlert2Module {\n  /**\n   * @param {?=} defaultSwalOptions\n   * @return {?}\n   */\n  static forRoot(defaultSwalOptions) {\n    return {\n      ngModule: SweetAlert2Module,\n      providers: [swalDefaultsProvider(defaultSwalOptions)]\n    };\n  }\n}\n\n/** @nocollapse */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { SwalPartialTargets, SwalComponent, SwalDirective, SwalPartialDirective, SweetAlert2Module, SwalDefaults as ɵa, swalDefaultsProvider as ɵb, SwalPartialComponent as ɵc };\n//# sourceMappingURL=toverux-ngx-sweetalert2.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
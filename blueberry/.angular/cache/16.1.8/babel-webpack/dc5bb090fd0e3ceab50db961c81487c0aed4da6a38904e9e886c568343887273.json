{"ast":null,"code":"import _asyncToGenerator from \"/home/orcrist/Desktop/touchpanel-ui-microservice/blueberry/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _defineProperty from \"/home/orcrist/Desktop/touchpanel-ui-microservice/blueberry/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, Directive, HostListener, Host, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nfunction _class4_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nconst swalProviderToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#swalProvider');\nconst fireOnInitToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#fireOnInit');\nconst dismissOnDestroyToken = new InjectionToken('@sweetalert2/ngx-sweetalert2#dismissOnDestroy');\nlet SweetAlert2LoaderService = /*#__PURE__*/(() => {\n  var _class;\n  class SweetAlert2LoaderService {\n    // Using any because Angular metadata generator does not understand a pure TS type here\n    constructor(swalProvider) {\n      _defineProperty(this, \"swalProvider\", void 0);\n      _defineProperty(this, \"swalPromiseCache\", void 0);\n      this.swalProvider = swalProvider;\n    }\n    get swal() {\n      if (!this.swalPromiseCache) {\n        this.preloadSweetAlertLibrary();\n      }\n      return this.swalPromiseCache;\n    }\n    preloadSweetAlertLibrary() {\n      if (this.swalPromiseCache) return;\n      const libPromise = isLoader(this.swalProvider) ? this.swalProvider() : Promise.resolve(this.swalProvider);\n      this.swalPromiseCache = libPromise.then(value => isDefaultExport(value) ? value : value.default);\n      function isLoader(value) {\n        return typeof value === 'function' && value.version === undefined;\n      }\n      function isDefaultExport(value) {\n        return typeof value === 'function';\n      }\n    }\n  }\n  _class = SweetAlert2LoaderService;\n  _defineProperty(SweetAlert2LoaderService, \"\\u0275fac\", function _class_Factory(t) {\n    return new (t || _class)(i0.ɵɵinject(swalProviderToken));\n  });\n  _defineProperty(SweetAlert2LoaderService, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac\n  }));\n  return SweetAlert2LoaderService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * <swal> component. See the README.md for usage.\n *\n * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.\n * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled\n * to SweetAlert2, but also is type-safe even if both libraries do not evolve in sync.\n *\n * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,\n *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.\n *\n * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.\n *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.\n *     If you are really concerned about performance and/or don't care about the API and its convenient integration\n *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)\n *\n * /!\\ Some SweetAlert options aren't @Inputs but @Outputs: `willOpen`, `didOpen`, `didRender`, `willClose`, `didClose`\n *     and `didDestroy`.\n *     However, `preConfirm`, `preDeny` and `inputValidator` are still @Inputs because they are not event handlers,\n *     there can't be multiple listeners on them, and we need the values they can/must return.\n */\nlet SwalComponent = /*#__PURE__*/(() => {\n  var _class2;\n  class SwalComponent {\n    /**\n     * An object of SweetAlert2 native options, useful if:\n     *  - you don't want to use the @Inputs for practical/philosophical reasons ;\n     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.\n     *\n     * /!\\ Please note that setting this property does NOT erase what has been set before unless you specify the\n     *     previous properties you want to erase again.\n     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.\n     *\n     * /!\\ Be aware that the options defined in this object will override the @Inputs of the same name.\n     */\n    set swalOptions(options) {\n      //=> Update properties\n      Object.assign(this, options);\n      //=> Mark changed properties as touched\n      const touchedKeys = Object.keys(options);\n      touchedKeys.forEach(this.markTouched);\n    }\n    /**\n     * Computes the options object that will get passed to SweetAlert2.\n     * Only the properties that have been set at least once on this component will be returned.\n     * Mostly for internal usage.\n     */\n    get swalOptions() {\n      //=> We will compute the options object based on the option keys that are known to have changed.\n      //   That avoids passing a gigantic object to SweetAlert2, making debugging easier and potentially\n      //   avoiding side effects.\n      return [...this.touchedProps].reduce((obj, key) => ({\n        ...obj,\n        [key]: this[key]\n      }), {});\n    }\n    /**\n     * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.\n     * When left undefined (default), the value will be inherited from the module configuration, which is `false`.\n     *\n     * Example:\n     *     <swal *ngIf=\"error\" [title]=\"error.title\" [text]=\"error.text\" icon=\"error\" [swalFireOnInit]=\"true\"></swal>\n     */\n\n    set swalVisible(visible) {\n      visible ? this.fire() : this.close();\n    }\n    get swalVisible() {\n      return this.isCurrentlyShown;\n    }\n    /**\n     * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n     */\n\n    constructor(sweetAlert2Loader, moduleLevelFireOnInit, moduleLevelDismissOnDestroy) {\n      _defineProperty(this, \"sweetAlert2Loader\", void 0);\n      _defineProperty(this, \"moduleLevelFireOnInit\", void 0);\n      _defineProperty(this, \"moduleLevelDismissOnDestroy\", void 0);\n      _defineProperty(this, \"title\", void 0);\n      _defineProperty(this, \"titleText\", void 0);\n      _defineProperty(this, \"text\", void 0);\n      _defineProperty(this, \"html\", void 0);\n      _defineProperty(this, \"footer\", void 0);\n      _defineProperty(this, \"icon\", void 0);\n      _defineProperty(this, \"iconColor\", void 0);\n      _defineProperty(this, \"iconHtml\", void 0);\n      _defineProperty(this, \"backdrop\", void 0);\n      _defineProperty(this, \"toast\", void 0);\n      _defineProperty(this, \"target\", void 0);\n      _defineProperty(this, \"input\", void 0);\n      _defineProperty(this, \"width\", void 0);\n      _defineProperty(this, \"padding\", void 0);\n      _defineProperty(this, \"background\", void 0);\n      _defineProperty(this, \"position\", void 0);\n      _defineProperty(this, \"grow\", void 0);\n      _defineProperty(this, \"showClass\", void 0);\n      _defineProperty(this, \"hideClass\", void 0);\n      _defineProperty(this, \"customClass\", void 0);\n      _defineProperty(this, \"timer\", void 0);\n      _defineProperty(this, \"timerProgressBar\", void 0);\n      _defineProperty(this, \"heightAuto\", void 0);\n      _defineProperty(this, \"allowOutsideClick\", void 0);\n      _defineProperty(this, \"allowEscapeKey\", void 0);\n      _defineProperty(this, \"allowEnterKey\", void 0);\n      _defineProperty(this, \"stopKeydownPropagation\", void 0);\n      _defineProperty(this, \"keydownListenerCapture\", void 0);\n      _defineProperty(this, \"showConfirmButton\", void 0);\n      _defineProperty(this, \"showDenyButton\", void 0);\n      _defineProperty(this, \"showCancelButton\", void 0);\n      _defineProperty(this, \"confirmButtonText\", void 0);\n      _defineProperty(this, \"denyButtonText\", void 0);\n      _defineProperty(this, \"cancelButtonText\", void 0);\n      _defineProperty(this, \"confirmButtonColor\", void 0);\n      _defineProperty(this, \"denyButtonColor\", void 0);\n      _defineProperty(this, \"cancelButtonColor\", void 0);\n      _defineProperty(this, \"confirmButtonAriaLabel\", void 0);\n      _defineProperty(this, \"denyButtonAriaLabel\", void 0);\n      _defineProperty(this, \"cancelButtonAriaLabel\", void 0);\n      _defineProperty(this, \"buttonsStyling\", void 0);\n      _defineProperty(this, \"reverseButtons\", void 0);\n      _defineProperty(this, \"focusConfirm\", void 0);\n      _defineProperty(this, \"focusDeny\", void 0);\n      _defineProperty(this, \"focusCancel\", void 0);\n      _defineProperty(this, \"showCloseButton\", void 0);\n      _defineProperty(this, \"closeButtonHtml\", void 0);\n      _defineProperty(this, \"closeButtonAriaLabel\", void 0);\n      _defineProperty(this, \"loaderHtml\", void 0);\n      _defineProperty(this, \"showLoaderOnConfirm\", void 0);\n      _defineProperty(this, \"preConfirm\", void 0);\n      _defineProperty(this, \"preDeny\", void 0);\n      _defineProperty(this, \"imageUrl\", void 0);\n      _defineProperty(this, \"imageWidth\", void 0);\n      _defineProperty(this, \"imageHeight\", void 0);\n      _defineProperty(this, \"imageAlt\", void 0);\n      _defineProperty(this, \"inputLabel\", void 0);\n      _defineProperty(this, \"inputPlaceholder\", void 0);\n      _defineProperty(this, \"inputValue\", void 0);\n      _defineProperty(this, \"inputOptions\", void 0);\n      _defineProperty(this, \"inputAutoTrim\", void 0);\n      _defineProperty(this, \"inputAttributes\", void 0);\n      _defineProperty(this, \"inputValidator\", void 0);\n      _defineProperty(this, \"returnInputValueOnDeny\", void 0);\n      _defineProperty(this, \"validationMessage\", void 0);\n      _defineProperty(this, \"progressSteps\", void 0);\n      _defineProperty(this, \"currentProgressStep\", void 0);\n      _defineProperty(this, \"progressStepsDistance\", void 0);\n      _defineProperty(this, \"scrollbarPadding\", void 0);\n      _defineProperty(this, \"swalFireOnInit\", void 0);\n      /**\n       * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.\n       * When left undefined (default), the value will be inherited from the module configuration, which is `true`.\n       */\n      _defineProperty(this, \"swalDismissOnDestroy\", void 0);\n      _defineProperty(this, \"willOpen\", new EventEmitter());\n      /**\n       * Modal lifecycle hook. Synchronously runs before the modal is shown on screen.\n       */\n      _defineProperty(this, \"didOpen\", new EventEmitter());\n      /**\n       * Modal lifecycle hook. Synchronously runs after the popup DOM has been updated (ie. just before the modal is\n       * repainted on the screen).\n       * Typically, this will happen after `Swal.fire()` or `Swal.update()`.\n       * If you want to perform changes in the popup's DOM, that survive `Swal.update()`, prefer {@link didRender} over\n       * {@link willOpen}.\n       */\n      _defineProperty(this, \"didRender\", new EventEmitter());\n      /**\n       * Modal lifecycle hook. Synchronously runs when the popup closes by user interaction (and not due to another popup\n       * being fired).\n       */\n      _defineProperty(this, \"willClose\", new EventEmitter());\n      /**\n       * Modal lifecycle hook. Asynchronously runs after the popup has been disposed by user interaction (and not due to\n       * another popup being fired).\n       */\n      _defineProperty(this, \"didClose\", new EventEmitter());\n      /**\n       * Modal lifecycle hook. Synchronously runs after popup has been destroyed either by user interaction or by another\n       * popup.\n       * If you have cleanup operations that you need to reliably execute each time a modal is closed, prefer\n       * {@link didDestroy} over {@link didClose}.\n       */\n      _defineProperty(this, \"didDestroy\", new EventEmitter());\n      /**\n       * Emits when the user clicks \"Confirm\".\n       * The event value ($event) can be either:\n       *  - by default, just `true`,\n       *  - when using {@link input}, the input value,\n       *  - when using {@link preConfirm}, the return value of this function.\n       *\n       * Example:\n       *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n       *\n       *     public handleConfirm(email: string): void {\n       *         // ... save user email\n       *     }\n       */\n      _defineProperty(this, \"confirm\", new EventEmitter());\n      /**\n       * Emits when the user clicks \"Deny\".\n       * This event bears no value.\n       * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and\n       * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.\n       *\n       * Example:\n       *     <swal (deny)=\"handleDeny()\"></swal>\n       *\n       *     public handleDeny(): void {\n       *     }\n       */\n      _defineProperty(this, \"deny\", new EventEmitter());\n      /**\n       * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n       * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when\n       * the modal was programmatically closed (through {@link close} for example).\n       *\n       * Example:\n       *     <swal (dismiss)=\"handleDismiss($event)\"></swal>\n       *\n       *     public handleDismiss(reason: DismissReason | undefined): void {\n       *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n       *         // ... do something\n       *     }\n       */\n      _defineProperty(this, \"dismiss\", new EventEmitter());\n      /**\n       * This Set retains the properties that have been changed from @Inputs, so we can know precisely\n       * what options we have to send to {@link Swal.fire}.\n       */\n      _defineProperty(this, \"touchedProps\", new Set());\n      /**\n       * A function of signature `(propName: string): void` that adds a given property name to the list of\n       * touched properties, ie. {@link touchedProps}.\n       */\n      _defineProperty(this, \"markTouched\", this.touchedProps.add.bind(this.touchedProps));\n      /**\n       * Is the SweetAlert2 modal represented by this component currently opened?\n       */\n      _defineProperty(this, \"isCurrentlyShown\", false);\n      this.sweetAlert2Loader = sweetAlert2Loader;\n      this.moduleLevelFireOnInit = moduleLevelFireOnInit;\n      this.moduleLevelDismissOnDestroy = moduleLevelDismissOnDestroy;\n    }\n    /**\n     * Angular lifecycle hook.\n     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there\n     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,\n     * causing no delay.\n     */\n    ngOnInit() {\n      //=> Preload SweetAlert2 library in case this component is activated.\n      this.sweetAlert2Loader.preloadSweetAlertLibrary();\n    }\n    /**\n     * Angular lifecycle hook.\n     * Fires the modal, if the component or module is configured to do so.\n     */\n    ngAfterViewInit() {\n      const fireOnInit = this.swalFireOnInit === undefined ? this.moduleLevelFireOnInit : this.swalFireOnInit;\n      fireOnInit && this.fire();\n    }\n    /**\n     * Angular lifecycle hook.\n     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.\n     */\n    ngOnChanges(changes) {\n      //=> For each changed @Input that matches a SweetAlert2 option, mark as touched so we can\n      //   send it with the next fire() or update() calls.\n      Object.keys(changes)\n      //=> If the filtering logic becomes more complex here, we can use Swal.isValidParameter\n      .filter(key => !key.startsWith('swal')).forEach(this.markTouched);\n      //=> Eventually trigger re-render if the modal is open.\n      void this.update();\n    }\n    /**\n     * Angular lifecycle hook.\n     * Closes the SweetAlert when the component is destroyed.\n     */\n    ngOnDestroy() {\n      //=> Release the modal if the component is destroyed and if that behaviour is not disabled.\n      const dismissOnDestroy = this.swalDismissOnDestroy === undefined ? this.moduleLevelDismissOnDestroy : this.swalDismissOnDestroy;\n      dismissOnDestroy && this.close();\n    }\n    /**\n     * Shows the SweetAlert.\n     *\n     * Returns the SweetAlert2 promise for convenience and use in code behind templates.\n     * Otherwise, (confirm)=\"myHandler($event)\" and (dismiss)=\"myHandler($event)\" can be used in templates.\n     */\n    fire() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const swal = yield _this.sweetAlert2Loader.swal;\n        const userOptions = _this.swalOptions;\n        //=> Build the SweetAlert2 options\n        const options = {\n          //=> Merge with calculated options set for that specific swal\n          ...userOptions,\n          //=> Handle modal lifecycle events\n          willOpen: composeHook(userOptions.willOpen, modalElement => {\n            _this.willOpen.emit({\n              modalElement\n            });\n          }),\n          didOpen: composeHook(userOptions.didOpen, modalElement => {\n            _this.isCurrentlyShown = true;\n            _this.didOpen.emit({\n              modalElement\n            });\n          }),\n          didRender: composeHook(userOptions.didRender, modalElement => {\n            _this.didRender.emit({\n              modalElement\n            });\n          }),\n          willClose: composeHook(userOptions.willClose, modalElement => {\n            _this.isCurrentlyShown = false;\n            _this.willClose.emit({\n              modalElement\n            });\n          }),\n          didClose: composeHook(userOptions.didClose, () => {\n            _this.didClose.emit();\n          }),\n          didDestroy: composeHook(userOptions.didDestroy, () => {\n            _this.didDestroy.emit();\n          })\n        };\n        //=> Show the Swal! And wait for confirmation or dimissal.\n        const result = yield swal.fire(options);\n        //=> Emit on (confirm), (deny) or (dismiss)\n        switch (true) {\n          case result.isConfirmed:\n            _this.confirm.emit(result.value);\n            break;\n          case result.isDenied:\n            _this.deny.emit();\n            break;\n          case result.isDismissed:\n            _this.dismiss.emit(result.dismiss);\n            break;\n        }\n        return result;\n        function composeHook(userHook, libHook) {\n          return (...args) => (libHook(...args), userHook?.(...args));\n        }\n      })();\n    }\n    /**\n     * Closes the modal, if opened.\n     *\n     * @param result The value that the modal will resolve with, triggering either (confirm), (deny) or (dismiss).\n     *               If the argument is not passed, it is (dismiss) that will emit an `undefined` reason.\n     *               {@see Swal.close}.\n     */\n    close(result) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this2.isCurrentlyShown) return;\n        const swal = yield _this2.sweetAlert2Loader.swal;\n        swal.close(result);\n      })();\n    }\n    /**\n     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.\n     * If the modal is not opened, the component options will simply be updated and that's it.\n     *\n     * /!\\ Please note that not all SweetAlert2 options are updatable while the modal is opened.\n     *\n     * @param options\n     */\n    update(options) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        if (options) {\n          _this3.swalOptions = options;\n        }\n        if (!_this3.isCurrentlyShown) return;\n        const swal = yield _this3.sweetAlert2Loader.swal;\n        const allOptions = _this3.swalOptions;\n        const updatableOptions = Object.keys(allOptions).filter(swal.isUpdatableParameter).reduce((obj, key) => ({\n          ...obj,\n          [key]: allOptions[key]\n        }), {});\n        swal.update(updatableOptions);\n      })();\n    }\n  }\n  _class2 = SwalComponent;\n  _defineProperty(SwalComponent, \"\\u0275fac\", function _class2_Factory(t) {\n    return new (t || _class2)(i0.ɵɵdirectiveInject(SweetAlert2LoaderService), i0.ɵɵdirectiveInject(fireOnInitToken), i0.ɵɵdirectiveInject(dismissOnDestroyToken));\n  });\n  _defineProperty(SwalComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class2,\n    selectors: [[\"swal\"]],\n    inputs: {\n      title: \"title\",\n      titleText: \"titleText\",\n      text: \"text\",\n      html: \"html\",\n      footer: \"footer\",\n      icon: \"icon\",\n      iconColor: \"iconColor\",\n      iconHtml: \"iconHtml\",\n      backdrop: \"backdrop\",\n      toast: \"toast\",\n      target: \"target\",\n      input: \"input\",\n      width: \"width\",\n      padding: \"padding\",\n      background: \"background\",\n      position: \"position\",\n      grow: \"grow\",\n      showClass: \"showClass\",\n      hideClass: \"hideClass\",\n      customClass: \"customClass\",\n      timer: \"timer\",\n      timerProgressBar: \"timerProgressBar\",\n      heightAuto: \"heightAuto\",\n      allowOutsideClick: \"allowOutsideClick\",\n      allowEscapeKey: \"allowEscapeKey\",\n      allowEnterKey: \"allowEnterKey\",\n      stopKeydownPropagation: \"stopKeydownPropagation\",\n      keydownListenerCapture: \"keydownListenerCapture\",\n      showConfirmButton: \"showConfirmButton\",\n      showDenyButton: \"showDenyButton\",\n      showCancelButton: \"showCancelButton\",\n      confirmButtonText: \"confirmButtonText\",\n      denyButtonText: \"denyButtonText\",\n      cancelButtonText: \"cancelButtonText\",\n      confirmButtonColor: \"confirmButtonColor\",\n      denyButtonColor: \"denyButtonColor\",\n      cancelButtonColor: \"cancelButtonColor\",\n      confirmButtonAriaLabel: \"confirmButtonAriaLabel\",\n      denyButtonAriaLabel: \"denyButtonAriaLabel\",\n      cancelButtonAriaLabel: \"cancelButtonAriaLabel\",\n      buttonsStyling: \"buttonsStyling\",\n      reverseButtons: \"reverseButtons\",\n      focusConfirm: \"focusConfirm\",\n      focusDeny: \"focusDeny\",\n      focusCancel: \"focusCancel\",\n      showCloseButton: \"showCloseButton\",\n      closeButtonHtml: \"closeButtonHtml\",\n      closeButtonAriaLabel: \"closeButtonAriaLabel\",\n      loaderHtml: \"loaderHtml\",\n      showLoaderOnConfirm: \"showLoaderOnConfirm\",\n      preConfirm: \"preConfirm\",\n      preDeny: \"preDeny\",\n      imageUrl: \"imageUrl\",\n      imageWidth: \"imageWidth\",\n      imageHeight: \"imageHeight\",\n      imageAlt: \"imageAlt\",\n      inputLabel: \"inputLabel\",\n      inputPlaceholder: \"inputPlaceholder\",\n      inputValue: \"inputValue\",\n      inputOptions: \"inputOptions\",\n      inputAutoTrim: \"inputAutoTrim\",\n      inputAttributes: \"inputAttributes\",\n      inputValidator: \"inputValidator\",\n      returnInputValueOnDeny: \"returnInputValueOnDeny\",\n      validationMessage: \"validationMessage\",\n      progressSteps: \"progressSteps\",\n      currentProgressStep: \"currentProgressStep\",\n      progressStepsDistance: \"progressStepsDistance\",\n      scrollbarPadding: \"scrollbarPadding\",\n      swalOptions: \"swalOptions\",\n      swalFireOnInit: \"swalFireOnInit\",\n      swalDismissOnDestroy: \"swalDismissOnDestroy\",\n      swalVisible: \"swalVisible\"\n    },\n    outputs: {\n      willOpen: \"willOpen\",\n      didOpen: \"didOpen\",\n      didRender: \"didRender\",\n      willClose: \"willClose\",\n      didClose: \"didClose\",\n      didDestroy: \"didDestroy\",\n      confirm: \"confirm\",\n      deny: \"deny\",\n      dismiss: \"dismiss\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function _class2_Template(rf, ctx) {},\n    encapsulation: 2,\n    changeDetection: 0\n  }));\n  return SwalComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * [swal] directive. It takes a value that defines the SweetAlert and can be of three types:\n *\n * 1) A simple array of two or three strings defining [title, text, icon] - the icon being optional, ex:\n *\n *    <button [swal]=\"['Title', 'Text']\">Click me</button>\n *\n * 2) A native SweetAlert2 options object, ex:\n *\n *    <button [swal]=\"{ title: 'Title', text: 'Text' }\">Click me</button>\n *\n * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:\n *\n *    <button [swal]=\"mySwal\">Click me</button>\n *    <swal #mySwal title=\"Title\" text=\"Text\"></swal>\n */\nlet SwalDirective = /*#__PURE__*/(() => {\n  var _class3;\n  class SwalDirective {\n    /**\n     * SweetAlert2 options or a SwalComponent instance.\n     * See the class doc block for more informations.\n     */\n    set swal(options) {\n      if (options instanceof SwalComponent) {\n        this.swalInstance = options;\n      } else if (isArrayOptions(options)) {\n        this.swalOptions = {};\n        [this.swalOptions.title, this.swalOptions.text, this.swalOptions.icon] = options;\n      } else {\n        this.swalOptions = options;\n      }\n      function isArrayOptions(value) {\n        return Array.isArray(options);\n      }\n    }\n    /**\n     * Emits when the user clicks \"Confirm\".\n     * The event value ($event) can be either:\n     *  - by default, just `true`,\n     *  - when using {@link input}, the input value,\n     *  - when using {@link preConfirm}, the return value of this function.\n     *\n     * Example:\n     *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n     *\n     *     public handleConfirm(email: string): void {\n     *         // ... save user email\n     *     }\n     */\n\n    constructor(viewContainerRef, resolver) {\n      _defineProperty(this, \"viewContainerRef\", void 0);\n      _defineProperty(this, \"resolver\", void 0);\n      _defineProperty(this, \"confirm\", new EventEmitter());\n      /**\n       * Emits when the user clicks \"Deny\".\n       * This event bears no value.\n       * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and\n       * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.\n       *\n       * Example:\n       *     <swal (deny)=\"handleDeny()\"></swal>\n       *\n       *     public handleDeny(): void {\n       *     }\n       */\n      _defineProperty(this, \"deny\", new EventEmitter());\n      /**\n       * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n       * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when\n       * the modal was programmatically closed (through {@link dismiss} for example).\n       *\n       * Example:\n       *     <swal (dismiss)=\"handleDismiss($event)\"></swal>\n       *\n       *     public handleDismiss(reason: DismissReason | undefined): void {\n       *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n       *         // ... do something\n       *     }\n       */\n      _defineProperty(this, \"dismiss\", new EventEmitter());\n      /**\n       * When the user does not provides a SwalComponent instance, we create it on-the-fly and assign the plain-object\n       * options to it.\n       * This fields keeps a reference to the dynamically-created <swal>, to destroy it along this directive instance.\n       */\n      _defineProperty(this, \"swalRef\", void 0);\n      /**\n       * An instance of the <swal> component that this directive controls.\n       * Could be an instance passed by the user, otherwise it's the instance we've dynamically created.\n       */\n      _defineProperty(this, \"swalInstance\", void 0);\n      /**\n       * Holds the native SweetAlert2 options.\n       * Empty when the user passed an existing SwalComponent instance.\n       */\n      _defineProperty(this, \"swalOptions\", void 0);\n      this.viewContainerRef = viewContainerRef;\n      this.resolver = resolver;\n    }\n    /**\n     * OnInit lifecycle handler.\n     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm),\n     * (deny) and (dismiss) outputs to reemit on the directive.\n     */\n    ngOnInit() {\n      if (!this.swalInstance) {\n        const factory = this.resolver.resolveComponentFactory(SwalComponent);\n        this.swalRef = this.viewContainerRef.createComponent(factory);\n        this.swalInstance = this.swalRef.instance;\n      }\n    }\n    /**\n     * OnDestroy lifecycle handler.\n     * Destroys the dynamically-created SwalComponent.\n     */\n    ngOnDestroy() {\n      if (this.swalRef) {\n        this.swalRef.destroy();\n      }\n    }\n    /**\n     * Click handler.\n     * The directive listens for onclick events on its host element.\n     * When this happens, it shows the <swal> attached to this directive.\n     */\n    onClick(event) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      if (!this.swalInstance) return;\n      if (this.swalOptions) {\n        this.swalInstance.swalOptions = this.swalOptions;\n      }\n      const swalClosed = new Subject();\n      this.swalInstance.confirm.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.confirm.emit(v));\n      this.swalInstance.deny.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.deny.emit(v));\n      this.swalInstance.dismiss.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.dismiss.emit(v));\n      this.swalInstance.fire().then(() => swalClosed.next());\n    }\n  }\n  _class3 = SwalDirective;\n  _defineProperty(SwalDirective, \"\\u0275fac\", function _class3_Factory(t) {\n    return new (t || _class3)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver));\n  });\n  _defineProperty(SwalDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class3,\n    selectors: [[\"\", \"swal\", \"\"]],\n    hostBindings: function _class3_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function _class3_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n    },\n    inputs: {\n      swal: \"swal\"\n    },\n    outputs: {\n      confirm: \"confirm\",\n      deny: \"deny\",\n      dismiss: \"dismiss\"\n    }\n  }));\n  return SwalDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @internal\n * Holds a consumer's Angular template and displays it on a Sweet Alert.\n * See SwalPortalDirective for info about the covered feature.\n */\nlet SwalPortalComponent = /*#__PURE__*/(() => {\n  var _class4;\n  class SwalPortalComponent {\n    constructor() {\n      _defineProperty(this, \"template\", null);\n    }\n  }\n  _class4 = SwalPortalComponent;\n  _defineProperty(SwalPortalComponent, \"\\u0275fac\", function _class4_Factory(t) {\n    return new (t || _class4)();\n  });\n  _defineProperty(SwalPortalComponent, \"\\u0275cmp\", /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class4,\n    selectors: [[\"swal-portal\"]],\n    inputs: {\n      template: \"template\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[4, \"ngTemplateOutlet\"]],\n    template: function _class4_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, _class4_ng_container_0_Template, 1, 0, \"ng-container\", 0);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template);\n      }\n    },\n    dependencies: [i1.NgTemplateOutlet],\n    encapsulation: 2,\n    changeDetection: 0\n  }));\n  return SwalPortalComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Represents an object of targets for <swal> portals (use with *swalPortal directive).\n * We must use thunks to access the Swal.* functions listed below, because they get created after the first modal is\n * shown, so this object lets us reference those functions safely and in a statically-typed manner.\n */\nlet SwalPortalTargets = /*#__PURE__*/(() => {\n  var _class5;\n  class SwalPortalTargets {\n    constructor() {\n      /**\n       * Targets the modal close button block contents.\n       */\n      _defineProperty(this, \"closeButton\", {\n        element: swal => swal.getCloseButton(),\n        options: {\n          showCloseButton: true\n        }\n      });\n      /**\n       * Targets the modal title block contents.\n       */\n      _defineProperty(this, \"title\", {\n        element: swal => swal.getTitle(),\n        // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n        options: {\n          title: ' '\n        }\n      });\n      /**\n       * Targets the modal text block contents (that is another block inside the first content block, so you can still\n       * use other modal features like Swal inputs, that are situated inside that parent content block).\n       */\n      _defineProperty(this, \"content\", {\n        element: swal => swal.getHtmlContainer(),\n        // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n        options: {\n          text: ' '\n        }\n      });\n      /**\n       * Targets the actions block contents, where are the confirm and cancel buttons in a normal time.\n       * /!\\ WARNING: using this target destroys some of the native SweetAlert2 modal's DOM, therefore, if you use this\n       *     target, do not update the modal via <swal> @Inputs while the modal is open, or you'll get an error.\n       *     We could workaround that inconvenient inside this integration, but that'd be detrimental to memory and\n       *     performance of everyone, for a relatively rare use case.\n       */\n      _defineProperty(this, \"actions\", {\n        element: swal => swal.getActions(),\n        // The button will never exist, but SweetAlert2 shows the actions block only if there is at least one button.\n        options: {\n          showConfirmButton: true\n        }\n      });\n      /**\n       * Targets the confirm button contents, replacing the text inside it (not the button itself)\n       */\n      _defineProperty(this, \"confirmButton\", {\n        element: swal => swal.getConfirmButton(),\n        options: {\n          showConfirmButton: true\n        }\n      });\n      /**\n       * Targets the deny button contents, replacing the text inside it (not the button itself)\n       */\n      _defineProperty(this, \"denyButton\", {\n        element: swal => swal.getDenyButton(),\n        options: {\n          showDenyButton: true\n        }\n      });\n      /**\n       * Targets the cancel button contents, replacing the text inside it (not the button itself)\n       */\n      _defineProperty(this, \"cancelButton\", {\n        element: swal => swal.getCancelButton(),\n        options: {\n          showCancelButton: true\n        }\n      });\n      /**\n       * Targets the modal footer contents.\n       */\n      _defineProperty(this, \"footer\", {\n        element: swal => swal.getFooter(),\n        // Empty text that will never be shown but necessary so SweetAlert2 makes the div visible.\n        options: {\n          footer: ' '\n        }\n      });\n    }\n  }\n  _class5 = SwalPortalTargets;\n  _defineProperty(SwalPortalTargets, \"\\u0275fac\", function _class5_Factory(t) {\n    return new (t || _class5)();\n  });\n  _defineProperty(SwalPortalTargets, \"\\u0275prov\", /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class5,\n    factory: _class5.ɵfac,\n    providedIn: 'root'\n  }));\n  return SwalPortalTargets;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A structural directive that lets you use Angular templates inside of SweetAlerts.\n * There are different targetable zones provided by {@link SwalPortalTargets}: title, content, confirmButton, etc, but\n * you can also make your own target by implementing {@link SwalPortalTarget} and giving it to this directive.\n * The default target is the alert text content zone.\n *\n * Usage in your component's TypeScript (if you use another target than {@link SwalPortalTargets.content}):\n *\n *     @Component({ ... })\n *     export class MyComponent {\n *         public constructor(public readonly swalTargets: SwalPortalTargets) {\n *         }\n *     }\n *\n * Usage in the template:\n *\n *     <swal title=\"Fill the form\" (confirm)=\"confirmHandler()\">\n *         <!-- This form will be displayed as the alert main content\n *              Targets the alert's main content zone by default -->\n *         <form *swalPortal [formControl]=\"myForm\">\n *             ...\n *         </form>\n *\n *         <!-- This targets the confirm button's inner content\n *              Notice the usage of ng-container to avoid creating an useless DOM element inside the button -->\n *         <ng-container *swalPortal=\"swalTargets.confirmButton\">\n *              Send ({{ secondsLeft }} seconds left)\n *         </ng-container>\n *     <swal>\n */\nlet SwalPortalDirective = /*#__PURE__*/(() => {\n  var _class6;\n  class SwalPortalDirective {\n    constructor(resolver, injector, app, templateRef, sweetAlert2Loader, swalTargets, swalComponent) {\n      _defineProperty(this, \"resolver\", void 0);\n      _defineProperty(this, \"injector\", void 0);\n      _defineProperty(this, \"app\", void 0);\n      _defineProperty(this, \"templateRef\", void 0);\n      _defineProperty(this, \"sweetAlert2Loader\", void 0);\n      _defineProperty(this, \"swalTargets\", void 0);\n      _defineProperty(this, \"swalComponent\", void 0);\n      /**\n       * Takes a portal target or nothing (then it will target the text content zone by default).\n       *\n       * See the {@link SwalPortalTargets} service to see the available targets.\n       * See the class doc block for more informations.\n       */\n      _defineProperty(this, \"target\", void 0);\n      /**\n       * Holds the component reference of the controlled SwalPortalComponent to destroy it when no longer needed.\n       */\n      _defineProperty(this, \"portalComponentRef\", void 0);\n      _defineProperty(this, \"destroyed\", new Subject());\n      this.resolver = resolver;\n      this.injector = injector;\n      this.app = app;\n      this.templateRef = templateRef;\n      this.sweetAlert2Loader = sweetAlert2Loader;\n      this.swalTargets = swalTargets;\n      this.swalComponent = swalComponent;\n    }\n    /**\n     * Subscribes to the the SweetAlert appearance/disappearance events to create/destroy the SwalPortalComponent\n     * that will receive the consumer's template.\n     */\n    ngOnInit() {\n      // Can't be set in a default property value, if the customer lets *swalPortal empty, the value we get is undef.\n      this.target = this.target || this.swalTargets.content;\n      //=> Apply the options provided by the target definition\n      void this.swalComponent.update(this.target.options);\n      //=> Subscribe to a few hooks frm the parent SwalComponent.\n      this.swalComponent.didRender.pipe(takeUntil(this.destroyed)).subscribe(this.didRenderHook.bind(this));\n      this.swalComponent.willOpen.pipe(takeUntil(this.destroyed)).subscribe(this.willOpenHook.bind(this));\n      this.swalComponent.didDestroy.pipe(takeUntil(this.destroyed)).subscribe(this.didDestroyHook.bind(this));\n    }\n    /**\n     * Signal any {@link destroyed} consumer that this is over, so they can unsubscribe from the\n     * parent SwalComponent events.\n     */\n    ngOnDestroy() {\n      this.destroyed.next();\n    }\n    /**\n     * This didRender hook runs 1..n times (per modal instance), just before the modal is shown (and also before the\n     * {@link willOpenHook}), or after Swal.update() is called.\n     * This is a good place to render, or re-render, our portal contents.\n     */\n    didRenderHook() {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        //=> Ensure the portal component is created\n        if (!_this4.portalComponentRef) {\n          _this4.portalComponentRef = _this4.createPortalComponent();\n        }\n        //=> SweetAlert2 created the modal or just erased all of our content, so we need to install/reinstall it.\n        // Swal.update() is synchronous, this observable too, and mountComponentOnTarget too (the promise inside\n        // this function is already resolved at this point), so the whole process of re-rendering and re-mounting\n        // the portal component is fully synchronous, causing no blinks in the modal contents.\n        const swal = yield _this4.sweetAlert2Loader.swal;\n        //=> Find target element\n        const targetEl = _this4.target.element(swal);\n        if (!targetEl) return;\n        //=> Replace target's contents with our component\n        // https://jsperf.com/innerhtml-vs-removechild/15\n        while (targetEl.firstChild) {\n          targetEl.removeChild(targetEl.firstChild);\n        }\n        targetEl.appendChild(_this4.portalComponentRef.location.nativeElement);\n      })();\n    }\n    /**\n     * This willOpen hook runs once (per modal instance), just before the modal is shown on the screen.\n     * This is a good place to declare our detached view to the Angular app.\n     */\n    willOpenHook() {\n      if (!this.portalComponentRef) return;\n      //=> Make the Angular app aware of that detached view so rendering and change detection can happen\n      this.app.attachView(this.portalComponentRef.hostView);\n    }\n    /**\n     * This didDestroy hook runs once (per modal instance), just after the modal closing animation terminated.\n     * This is a good place to detach and destroy our content, that is not visible anymore.\n     */\n    didDestroyHook() {\n      if (!this.portalComponentRef) return;\n      //=> Detach the portal component from the app and destroy it\n      this.app.detachView(this.portalComponentRef.hostView);\n      this.portalComponentRef.destroy();\n      this.portalComponentRef = void 0;\n    }\n    /**\n     * Creates the {@link SwalPortalComponent} and gives it the customer's template ref.\n     */\n    createPortalComponent() {\n      //=> Create the SwalPortalComponent that will hold our content\n      const factory = this.resolver.resolveComponentFactory(SwalPortalComponent);\n      // Yes, we do not use the third argument that would directly use the target as the component's view\n      // (unfortunately, because that would give a cleaner DOM and would avoid dirty and direct DOM manipulations)\n      // That's because we want to keep our component safe from SweetAlert2's operations on the DOM, and to be\n      // able to restore it at any moment, ie. after the modal has been re-rendered.\n      const componentRef = factory.create(this.injector, []);\n      //=> Apply the consumer's template on the component\n      componentRef.instance.template = this.templateRef;\n      return componentRef;\n    }\n  }\n  _class6 = SwalPortalDirective;\n  _defineProperty(SwalPortalDirective, \"\\u0275fac\", function _class6_Factory(t) {\n    return new (t || _class6)(i0.ɵɵdirectiveInject(i0.ComponentFactoryResolver), i0.ɵɵdirectiveInject(i0.Injector), i0.ɵɵdirectiveInject(i0.ApplicationRef), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(SweetAlert2LoaderService), i0.ɵɵdirectiveInject(SwalPortalTargets), i0.ɵɵdirectiveInject(SwalComponent, 1));\n  });\n  _defineProperty(SwalPortalDirective, \"\\u0275dir\", /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class6,\n    selectors: [[\"\", \"swalPortal\", \"\"]],\n    inputs: {\n      target: [\"swalPortal\", \"target\"]\n    }\n  }));\n  return SwalPortalDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction provideDefaultSwal() {\n  return import('sweetalert2');\n}\nlet SweetAlert2Module = /*#__PURE__*/(() => {\n  var _class7;\n  class SweetAlert2Module {\n    static forRoot(options = {}) {\n      return {\n        ngModule: SweetAlert2Module,\n        providers: [SweetAlert2LoaderService, {\n          provide: swalProviderToken,\n          useValue: options.provideSwal || provideDefaultSwal\n        }, {\n          provide: fireOnInitToken,\n          useValue: options.fireOnInit || false\n        }, {\n          provide: dismissOnDestroyToken,\n          useValue: options.dismissOnDestroy || true\n        }]\n      };\n    }\n    static forChild(options = {}) {\n      return {\n        ngModule: SweetAlert2Module,\n        providers: [...(options.provideSwal ? [SweetAlert2LoaderService, {\n          provide: swalProviderToken,\n          useValue: options.provideSwal\n        }] : []), ...(options.fireOnInit !== undefined ? [{\n          provide: fireOnInitToken,\n          useValue: options.fireOnInit\n        }] : []), ...(options.dismissOnDestroy !== undefined ? [{\n          provide: dismissOnDestroyToken,\n          useValue: options.dismissOnDestroy\n        }] : [])]\n      };\n    }\n  }\n  _class7 = SweetAlert2Module;\n  _defineProperty(SweetAlert2Module, \"\\u0275fac\", function _class7_Factory(t) {\n    return new (t || _class7)();\n  });\n  _defineProperty(SweetAlert2Module, \"\\u0275mod\", /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class7\n  }));\n  _defineProperty(SweetAlert2Module, \"\\u0275inj\", /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  }));\n  return SweetAlert2Module;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SwalComponent, SwalDirective, SwalPortalDirective, SwalPortalTargets, SweetAlert2LoaderService, SweetAlert2Module };\n//# sourceMappingURL=sweetalert2-ngx-sweetalert2.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
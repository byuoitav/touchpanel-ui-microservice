{"ast":null,"code":"import _defineProperty from \"/home/orcrist/Desktop/touchpanel-ui-microservice/blueberry/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { EventEmitter } from \"@angular/core\";\nimport { HttpClient, HttpRequest } from \"@angular/common/http\";\nimport { catchError, tap, timeout } from 'rxjs/operators';\nimport { of } from \"rxjs\";\nimport { APIService } from \"./api.service\";\nimport { DataService } from \"./data.service\";\nimport { Event, BasicDeviceInfo, BasicRoomInfo } from \"./socket.service\";\nimport { Display, AudioDevice } from \"../objects/status.objects\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./data.service\";\nimport * as i3 from \"./api.service\";\nconst TIMEOUT = 12 * 1000;\nclass CommandRequest {\n  constructor(req, delay) {\n    _defineProperty(this, \"req\", void 0);\n    _defineProperty(this, \"delay\", void 0);\n    this.req = req;\n    if (delay) {\n      this.delay = delay;\n    } else {\n      this.delay = 0;\n    }\n  }\n}\nexport let CommandService = /*#__PURE__*/(() => {\n  var _class2;\n  class CommandService {\n    constructor(http, data, api) {\n      _defineProperty(this, \"http\", void 0);\n      _defineProperty(this, \"data\", void 0);\n      _defineProperty(this, \"api\", void 0);\n      _defineProperty(this, \"options\", void 0);\n      this.http = http;\n      this.data = data;\n      this.api = api;\n      const headers = new Headers();\n      headers.append(\"content-type\", \"application/json\");\n      this.options = new HttpRequest(\"GET\", \"\", {\n        headers: headers\n      });\n    }\n    executeRequests(requests, maxTries, timeout) {\n      const ret = new EventEmitter();\n      if (requests.length < 1) {\n        setTimeout(() => ret.emit(false), 250);\n        return ret;\n      }\n      console.info(\"executing requests: \", requests);\n      const numRequests = requests.length;\n      const mapToStatus = new Map();\n      for (const req of requests) {\n        this.executeRequest(req, maxTries, timeout).subscribe(success => {\n          mapToStatus.set(req, success);\n          if (mapToStatus.size === numRequests) {\n            console.info(\"finished all requests, requests => success:\", mapToStatus);\n            let allsuccessful = true;\n            mapToStatus.forEach((v, k) => {\n              if (!v) {\n                allsuccessful = false;\n              }\n            });\n            ret.emit(allsuccessful);\n            return;\n          }\n        });\n      }\n      console.log(\"waiting for\", requests.length, \"responses...\");\n      return ret;\n    }\n    executeRequest(req, maxTries, timeOut) {\n      const ret = new EventEmitter();\n      console.log(\"executing request\", req);\n      setTimeout(() => {\n        this.http.request(req.req).pipe(timeout(timeOut), catchError(this.handleError(\"executeRequest\", []))).subscribe({\n          next: data => {\n            console.log(\"successfully executed request\", req);\n            console.log(\"data\", data);\n            ret.emit(true);\n            return;\n          },\n          error: err => {\n            maxTries--;\n            if (maxTries === 0) {\n              ret.emit(false);\n              return;\n            }\n            // retry request\n            console.error(\"request (\" + req + \") failed. error:\", err, \". There are\", maxTries, \" remaining, retrying in 3 seconds...\");\n            setTimeout(() => this.executeRequest(req, maxTries, timeOut), 3000);\n          },\n          complete: () => {\n            console.log(\"request completed\");\n          }\n        });\n      }, req.delay);\n      return ret;\n    }\n    buildRequest(cmd) {\n      // if we needed logic to create a request, it would be right here!!\n      return new CommandRequest(new HttpRequest(cmd.method, APIService.apihost + \":\" + cmd.port + \"/\" + cmd.endpoint, {\n        body: cmd.body\n      }), cmd.delay);\n    }\n    put(data) {\n      return this.http.put(APIService.apiurl, data, this.options.body).pipe(timeout(TIMEOUT), tap(_ => console.log(\"put data:\", data)), catchError(this.handleError(\"put\", [])));\n    }\n    putWithCustomTimeout(data, timeOut) {\n      return this.http.put(APIService.apiurl, data, this.options.body).pipe(timeout(timeOut), catchError(this.handleError(\"putWithCustomTimeout\", [])));\n    }\n    setPower(p, displays) {\n      const ret = new EventEmitter();\n      console.log(\"Setting power to\", p, \"on\", displays);\n      const prev = Display.getPower(displays);\n      Display.setPower(p, displays);\n      const body = {\n        displays: []\n      };\n      for (const d of displays) {\n        body.displays.push({\n          name: d.name,\n          power: p\n        });\n      }\n      this.put(body).subscribe({\n        next: data => {\n          console.log(\"put data\", data);\n          ret.emit(true);\n        },\n        error: err => {\n          console.error(\"put error\", err);\n          Display.setPower(prev, displays);\n          ret.emit(false);\n        },\n        complete: () => {\n          console.log(\"put completed\");\n        }\n      });\n      return ret;\n    }\n    setInput(i, displays) {\n      // i.click.emit();\n      const ret = new EventEmitter();\n      console.log(\"Changing input on\", displays, \"to\", i.name);\n      const prev = Display.getInput(displays);\n      Display.setInput(i, displays);\n      const body = {\n        displays: []\n      };\n      for (const d of displays) {\n        body.displays.push({\n          name: d.name,\n          input: i.name\n        });\n      }\n      this.put(body).subscribe({\n        next: data => {\n          console.log(\"put data\", data);\n          ret.emit(true);\n        },\n        error: err => {\n          console.error(\"put error\", err);\n          Display.setInput(prev, displays);\n          ret.emit(false);\n        },\n        complete: () => {\n          console.log(\"put completed\");\n        }\n      });\n      return ret;\n    }\n    setBlank(b, displays) {\n      const ret = new EventEmitter();\n      console.log(\"Setting blanked to\", b, \"on\", displays);\n      const prev = Display.getBlank(displays);\n      Display.setBlank(b, displays);\n      const body = {\n        displays: []\n      };\n      for (const d of displays) {\n        body.displays.push({\n          name: d.name,\n          blanked: b\n        });\n      }\n      this.put(body).subscribe({\n        next: data => {\n          console.log(\"put data\", data);\n          ret.emit(true);\n        },\n        error: err => {\n          console.error(\"put error\", err);\n          Display.setBlank(prev, displays);\n          ret.emit(false);\n        },\n        complete: () => {\n          console.log(\"put completed\");\n        }\n      });\n      return ret;\n    }\n    setVolume(v, devices) {\n      const ret = new EventEmitter();\n      console.log(\"changing volume to\", v, \"on\", devices);\n      const prev = AudioDevice.getVolume(devices);\n      AudioDevice.setVolume(v, devices);\n      const body = {\n        audioDevices: []\n      };\n      for (const a of devices) {\n        body.audioDevices.push({\n          name: a.name,\n          volume: v\n        });\n      }\n      console.log(\"volume body\", body);\n      this.put(body).subscribe({\n        next: data => {\n          console.log(\"put data\", data);\n          ret.emit(true);\n        },\n        error: err => {\n          console.error(\"put error\", err);\n          AudioDevice.setVolume(prev, devices);\n          ret.emit(false);\n        },\n        complete: () => {\n          console.log(\"put completed\");\n        }\n      });\n      return ret;\n    }\n    setMute(m, devices) {\n      const ret = new EventEmitter();\n      console.log(\"changing mute to\", m, \"on\", devices);\n      const prev = AudioDevice.getMute(devices);\n      AudioDevice.setMute(m, devices);\n      const body = {\n        audioDevices: []\n      };\n      for (const a of devices) {\n        body.audioDevices.push({\n          name: a.name,\n          muted: m\n        });\n      }\n      this.put(body).subscribe({\n        next: data => {\n          console.log(\"put data\", data);\n          ret.emit(true);\n        },\n        error: err => {\n          console.error(\"put error\", err);\n          AudioDevice.setMute(prev, devices);\n          ret.emit(false);\n        },\n        complete: () => {\n          console.log(\"put completed\");\n        }\n      });\n      return ret;\n    }\n    powerOnDefault(preset) {\n      const ret = new EventEmitter();\n      const body = {\n        displays: [],\n        audioDevices: []\n      };\n      for (const d of preset.displays) {\n        body.displays.push({\n          name: d.name,\n          power: \"on\",\n          input: preset.inputs[0].name,\n          blanked: false\n        });\n      }\n      for (const a of preset.audioDevices) {\n        body.audioDevices.push({\n          name: a.name,\n          power: \"on\",\n          muted: false,\n          volume: 30\n        });\n      }\n      const powerOnReq = new CommandRequest(new HttpRequest(\"PUT\", APIService.apiurl, body));\n      const requests = [powerOnReq];\n      if (preset.commands.powerOn != null) {\n        for (const cmd of preset.commands.powerOn) {\n          requests.push(this.buildRequest(cmd));\n        }\n      }\n      this.executeRequests(requests, 1, 20 * 1000).subscribe(success => {\n        ret.emit(success);\n      });\n      return ret;\n    }\n    powerOff(preset) {\n      const ret = new EventEmitter();\n      const body = {\n        displays: [],\n        audioDevices: []\n      };\n      for (const d of preset.displays) {\n        body.displays.push({\n          name: d.name,\n          power: \"standby\"\n        });\n      }\n      for (const a of preset.audioDevices) {\n        body.audioDevices.push({\n          name: a.name,\n          power: \"standby\"\n        });\n      }\n      console.log(\"sending power off body\", body);\n      const powerOffReq = new CommandRequest(new HttpRequest(\"PUT\", APIService.apiurl, body));\n      const requests = [powerOffReq];\n      if (preset.commands.powerOff != null) {\n        for (const cmd of preset.commands.powerOff) {\n          requests.push(this.buildRequest(cmd));\n        }\n      }\n      this.executeRequests(requests, 1, 20 * 1000).subscribe(success => {\n        ret.emit(success);\n      });\n      return ret;\n    }\n    powerOffAll() {\n      const ret = new EventEmitter();\n      const body = {\n        power: \"standby\"\n      };\n      this.put(body).subscribe({\n        next: data => {\n          console.log(\"put data\", data);\n          ret.emit(true);\n        },\n        error: err => {\n          console.error(\"put error\", err);\n          ret.emit(false);\n        },\n        complete: () => {\n          console.log(\"put completed\");\n        }\n      });\n      return ret;\n    }\n    share(from, to) {\n      const ret = new EventEmitter();\n      if (!from.displays[0] || !from.displays[0].input) {\n        setTimeout(() => ret.emit(false), 150);\n        return ret;\n      }\n      const input = from.displays[0].input;\n      // displays i'm sharing to\n      const displays = from.displays.slice();\n      to.forEach(p => displays.push(...p.displays));\n      const body = {\n        displays: [],\n        audioDevices: []\n      };\n      for (const preset of to) {\n        for (const disp of preset.displays) {\n          body.displays.push({\n            name: disp.name,\n            power: \"on\",\n            blanked: false,\n            input: input.name\n          });\n        }\n      }\n      const audioConfigs = this.data.getAudioConfigurations(displays);\n      const hasRoomWide = this.data.hasRoomWide(audioConfigs);\n      if (hasRoomWide) {\n        // mute all the non-roomwide audio devices, unmute all roomwide\n        for (const config of audioConfigs) {\n          for (const audio of config.audioDevices) {\n            if (config.roomWide) {\n              body.audioDevices.push({\n                name: audio.name,\n                muted: false,\n                volume: 30\n              });\n            } else {\n              body.audioDevices.push({\n                name: audio.name,\n                muted: true\n              });\n            }\n          }\n        }\n      } else {\n        // mute everything except for yourself\n        for (const config of audioConfigs) {\n          for (const audio of config.audioDevices) {\n            if (!from.audioDevices.some(a => a.name === audio.name)) {\n              body.audioDevices.push({\n                name: audio.name,\n                muted: true\n              });\n            }\n          }\n        }\n      }\n      console.log(\"share body:\", body);\n      this.putWithCustomTimeout(body, 20 * 1000).subscribe({\n        next: data => {\n          console.log(\"share\", data);\n          ret.emit(true);\n        },\n        error: err => {\n          console.error(\"share\", err);\n          ret.emit(false);\n        },\n        complete: () => {\n          console.log(\"share completed\");\n        }\n      });\n      return ret;\n    }\n    unshare(from, to) {\n      const ret = new EventEmitter();\n      const body = {\n        displays: [],\n        audioDevices: []\n      };\n      for (const preset of to) {\n        for (const disp of preset.displays) {\n          body.displays.push({\n            name: disp.name,\n            power: \"on\",\n            input: preset.inputs[0].name,\n            blanked: false\n          });\n        }\n        for (const device of preset.audioDevices) {\n          body.audioDevices.push({\n            name: device.name,\n            power: \"on\",\n            volume: 30,\n            muted: false\n          });\n        }\n      }\n      /*\n      for (const disp of from.displays) {\n        body.displays.push({\n          name: disp.name,\n          power: \"on\",\n          input: from.inputs[0].name,\n          blanked: false\n        });\n      }\n           for (const device of from.audioDevices) {\n        body.audioDevices.push({\n          name: device.name,\n          power: \"on\",\n          volume: 30,\n          muted: false\n        });\n      }\n      */\n      console.log(\"unshare body\", body);\n      this.putWithCustomTimeout(body, 20 * 1000).subscribe({\n        next: data => {\n          console.log(\"unshare\", data);\n          ret.emit(true);\n        },\n        error: err => {\n          console.error(\"unshare\", err);\n          ret.emit(false);\n        },\n        complete: () => {\n          console.log(\"unshare completed\");\n        }\n      });\n      return ret;\n    }\n    mirror(minion, master) {\n      const ret = new EventEmitter();\n      const body = {\n        displays: []\n      };\n      const power = Display.getPower(master.displays);\n      const input = Display.getInput(master.displays);\n      const blanked = Display.getBlank(master.displays);\n      for (const d of minion.displays) {\n        body.displays.push({\n          name: d.name,\n          power: power,\n          input: input.name,\n          blanked: blanked\n        });\n      }\n      console.log(\"mirror body\", body);\n      this.put(body).subscribe({\n        next: data => {\n          console.log(\"mirror\", data);\n          ret.emit(true);\n        },\n        error: err => {\n          console.error(\"mirror\", err);\n          ret.emit(false);\n        },\n        complete: () => {\n          console.log(\"mirror completed\");\n        }\n      });\n      return ret;\n    }\n    buttonPress(value, data) {\n      const event = new Event();\n      event.EventTags = [\"ui-event\", \"blueberry-ui\"];\n      event.AffectedRoom = new BasicRoomInfo(APIService.building + \"-\" + APIService.roomName);\n      event.TargetDevice = new BasicDeviceInfo(APIService.piHostname);\n      event.GeneratingSystem = APIService.piHostname;\n      event.Timestamp = new Date();\n      event.User = \"\";\n      event.Data = data;\n      event.Key = \"user-interaction\";\n      event.Value = value;\n      this.api.sendEvent(event);\n    }\n    handleError(operation = \"operation\", result) {\n      return error => {\n        console.error(\"error doing ${operation}\", error);\n        return of(result);\n      };\n    }\n  }\n  _class2 = CommandService;\n  _defineProperty(CommandService, \"\\u0275fac\", function CommandService_Factory(t) {\n    return new (t || _class2)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.DataService), i0.ɵɵinject(i3.APIService));\n  });\n  _defineProperty(CommandService, \"\\u0275prov\", /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _class2,\n    factory: _class2.ɵfac\n  }));\n  return CommandService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
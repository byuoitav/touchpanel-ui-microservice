{"ast":null,"code":"import _defineProperty from \"/home/orcrist/Desktop/touchpanel-ui-microservice/cherry/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { EventEmitter } from \"@angular/core\";\nimport { HttpClient, HttpRequest } from \"@angular/common/http\";\nimport { MatDialog } from \"@angular/material/dialog\";\nimport { APIService } from \"./api.service\";\nimport { DataService } from \"./data.service\";\nimport { Event, BasicDeviceInfo, BasicRoomInfo } from \"./socket.service\";\nimport { Display, AudioDevice } from \"../objects/status.objects\";\nimport { Preset, ConfigCommand } from \"../objects/objects\";\nimport { of } from \"rxjs\";\nimport { catchError, tap, timeout } from 'rxjs/operators';\nimport { map } from \"rxjs\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./data.service\";\nimport * as i3 from \"./api.service\";\nimport * as i4 from \"@angular/material/dialog\";\nconst TIMEOUT = 12 * 1000;\nclass CommandRequest {\n  constructor(req, delay) {\n    _defineProperty(this, \"req\", void 0);\n    _defineProperty(this, \"delay\", void 0);\n    this.req = req;\n    if (delay) {\n      this.delay = delay;\n    } else {\n      this.delay = 0;\n    }\n  }\n}\nexport let CommandService = /*#__PURE__*/(() => {\n  var _class2;\n  class CommandService {\n    constructor(http, data, api, dialog) {\n      _defineProperty(this, \"http\", void 0);\n      _defineProperty(this, \"data\", void 0);\n      _defineProperty(this, \"api\", void 0);\n      _defineProperty(this, \"dialog\", void 0);\n      _defineProperty(this, \"options\", void 0);\n      this.http = http;\n      this.data = data;\n      this.api = api;\n      this.dialog = dialog;\n      const headers = new Headers();\n      headers.append(\"content-type\", \"application/json\");\n      this.options = new HttpRequest(\"GET\", \"\", {\n        headers: headers\n      });\n    }\n    put(data) {\n      return this.http.put(APIService.apiurl, data, this.options.body).pipe(timeout(TIMEOUT), tap(res => console.log(\"PUT response\", res)), map(res => res), catchError(this.handleError(\"put\", [])));\n    }\n    putWithCustomTimeout(data, timeOut) {\n      return this.http.put(APIService.apiurl, data, this.options.body).pipe(timeout(timeOut), tap(res => console.log(\"PUT response\", res)), map(res => res), catchError(this.handleError(\"\", [])));\n    }\n    setPower(p, displays) {\n      const ret = new EventEmitter();\n      console.log(\"Setting power to\", p, \"on\", displays);\n      const prev = Display.getPower(displays);\n      Display.setPower(p, displays);\n      const body = {\n        displays: []\n      };\n      for (const d of displays) {\n        body.displays.push({\n          name: d.name,\n          power: p\n        });\n      }\n      this.put(body).subscribe(data => {\n        ret.emit(true);\n      }, err => {\n        Display.setPower(p, displays);\n        ret.emit(false);\n      });\n      return ret;\n    }\n    setInput(preset, i, displays) {\n      i.click.emit();\n      const ret = new EventEmitter();\n      console.log(\"Changing input on\", displays, \"to\", i.name);\n      const prev = Display.getInput(displays);\n      Display.setInput(i, displays);\n      // because we also want to unblank for this ui\n      const prevBlank = Display.getBlank(displays);\n      Display.setBlank(false, displays);\n      const body = {\n        displays: []\n      };\n      for (const d of displays) {\n        body.displays.push({\n          name: d.name,\n          input: i.name,\n          blanked: false\n        });\n      }\n      const changeInputReq = new CommandRequest(new HttpRequest(\"PUT\", APIService.apiurl, body));\n      const requests = [changeInputReq];\n      const commandsToUse = preset.displays.some(d => d.input && d.input.name !== i.name) ? preset.commands.inputDifferent : preset.commands.inputSame;\n      if (commandsToUse) {\n        for (const cmd of commandsToUse) {\n          requests.push(this.buildRequest(cmd));\n        }\n      }\n      console.log(\"preset:\", preset);\n      console.log(\"executing requests:\", requests);\n      this.executeRequests(requests, 1, 14 * 1000).subscribe(success => {\n        if (!success) {\n          console.warn(\"cannot set input, reverting displays back to previous selection\");\n          Display.setInput(prev, displays);\n          Display.setBlank(prevBlank, displays);\n        }\n        ret.emit(success);\n      });\n      return ret;\n    }\n    setBlank(b, displays) {\n      const ret = new EventEmitter();\n      console.log(\"Setting blanked to\", b, \"on\", displays);\n      const prev = Display.getBlank(displays);\n      Display.setBlank(b, displays);\n      const body = {\n        displays: []\n      };\n      for (const d of displays) {\n        body.displays.push({\n          name: d.name,\n          blanked: b\n        });\n      }\n      this.put(body).pipe(timeout(TIMEOUT), tap(res => console.log(\"PUT response\", res))).subscribe({\n        next: data => {\n          ret.emit(true);\n          console.log(\"next\", data);\n        },\n        error: err => {\n          Display.setBlank(prev, displays);\n          ret.emit(false);\n          console.warn(\"error setting blank\", err);\n        },\n        complete: () => {\n          console.log(\"complete\");\n        }\n      });\n      return ret;\n    }\n    setVolume(v, audioDevices) {\n      const ret = new EventEmitter();\n      console.log(\"changing volume to\", v, \"on\", audioDevices);\n      const prev = AudioDevice.getVolume(audioDevices);\n      AudioDevice.setVolume(v, audioDevices);\n      const body = {\n        audioDevices: []\n      };\n      for (const a of audioDevices) {\n        body.audioDevices.push({\n          name: a.name,\n          volume: v\n        });\n      }\n      console.log(\"volume body\", body);\n      this.put(body).pipe(timeout(TIMEOUT), tap(res => console.log(\"PUT response\", res))).subscribe({\n        next: data => {\n          ret.emit(true);\n          console.log(\"next\", data);\n        },\n        error: err => {\n          AudioDevice.setVolume(prev, audioDevices);\n          ret.emit(false);\n          console.warn(\"error setting volume\", err);\n        },\n        complete: () => {\n          console.log(\"complete\");\n        }\n      });\n      return ret;\n    }\n    setMute(m, audioDevices) {\n      const ret = new EventEmitter();\n      console.log(\"changing mute to\", m, \"on\", audioDevices);\n      const prev = AudioDevice.getMute(audioDevices);\n      AudioDevice.setMute(m, audioDevices);\n      const body = {\n        audioDevices: []\n      };\n      for (const a of audioDevices) {\n        body.audioDevices.push({\n          name: a.name,\n          muted: m\n        });\n      }\n      this.put(body).pipe(timeout(TIMEOUT), tap(res => console.log(\"PUT response\", res))).subscribe({\n        next: data => {\n          ret.emit(true);\n          console.log(\"next\", data);\n        },\n        error: err => {\n          AudioDevice.setMute(prev, audioDevices);\n          ret.emit(false);\n          console.warn(\"error setting mute\", err);\n        },\n        complete: () => {\n          console.log(\"complete\");\n        }\n      });\n      return ret;\n    }\n    setMuteAndVolume(m, v, audioDevices) {\n      const ret = new EventEmitter();\n      console.log(\"changing volume to\", v, \"and mute to\", m, \"on\", audioDevices);\n      const prevMute = AudioDevice.getMute(audioDevices);\n      AudioDevice.setMute(m, audioDevices);\n      const prevVol = AudioDevice.getVolume(audioDevices);\n      AudioDevice.setVolume(v, audioDevices);\n      const body = {\n        audioDevices: []\n      };\n      for (const a of audioDevices) {\n        body.audioDevices.push({\n          name: a.name,\n          volume: v,\n          muted: m\n        });\n      }\n      this.put(body).pipe(timeout(TIMEOUT), tap(res => console.log(\"PUT response\", res))).subscribe({\n        next: data => {\n          ret.emit(true);\n          console.log(\"next\", data);\n        },\n        error: err => {\n          AudioDevice.setMute(prevMute, audioDevices);\n          AudioDevice.setVolume(prevVol, audioDevices);\n          ret.emit(false);\n          console.warn(\"error setting mute and volume\", err);\n        },\n        complete: () => {\n          console.log(\"complete\");\n        }\n      });\n      return ret;\n    }\n    setMasterVolume(v, preset) {\n      const ret = new EventEmitter();\n      console.log(\"changing master volume to\", v, \"for preset\", preset);\n      const prev = preset.masterVolume;\n      preset.masterVolume = v;\n      const body = {\n        audioDevices: []\n      };\n      for (const a of preset.audioDevices) {\n        const vol = a.mixlevel * (v / 100);\n        body.audioDevices.push({\n          name: a.name,\n          volume: Math.round(vol),\n          muted: a.mixmute\n        });\n      }\n      console.log(\"volume body\", body);\n      this.put(body).pipe(timeout(TIMEOUT), tap(res => console.log(\"PUT response\", res))).subscribe({\n        // post master volume change event\n        next: data => {\n          const event = new Event();\n          event.User = APIService.piHostname;\n          event.EventTags = [\"ui-communication\"];\n          event.AffectedRoom = new BasicRoomInfo(APIService.building + \"-\" + APIService.roomName);\n          event.TargetDevice = new BasicDeviceInfo(APIService.building + \"-\" + APIService.roomName + \"-\" + preset.name);\n          event.Key = \"master-volume\";\n          event.Value = String(v);\n          event.Data = preset.name;\n          this.api.sendEvent(event);\n          ret.emit(true);\n          console.log(\"next\", data);\n        },\n        error: err => {\n          preset.masterVolume = prev;\n          ret.emit(false);\n          console.warn(\"error setting master volume\", err);\n        },\n        complete: () => {\n          console.log(\"complete\");\n        }\n      });\n      return ret;\n    }\n    setMasterMute(m, preset) {\n      const ret = new EventEmitter();\n      console.log(\"changing master mute to\", m, \"for preset\", preset);\n      const prev = preset.masterMute;\n      preset.masterMute = m;\n      const body = {\n        audioDevices: []\n      };\n      for (const a of preset.audioDevices) {\n        body.audioDevices.push({\n          name: a.name,\n          muted: a.mixmute || m\n        });\n      }\n      console.log(\"master mute body\", body);\n      this.put(body).pipe(timeout(TIMEOUT), tap(res => console.log(\"PUT response\", res))).subscribe({\n        next: data => {\n          const event = new Event();\n          event.User = APIService.piHostname;\n          event.EventTags = [\"ui-communication\"];\n          event.AffectedRoom = new BasicRoomInfo(APIService.building + \"-\" + APIService.roomName);\n          event.TargetDevice = new BasicDeviceInfo(APIService.building + \"-\" + APIService.roomName + \"-\" + preset.name);\n          event.Key = \"master-mute\";\n          event.Value = String(m);\n          event.Data = preset.name;\n          this.api.sendEvent(event);\n          ret.emit(true);\n          console.log(\"next\", data);\n        },\n        error: err => {\n          preset.masterMute = prev;\n          ret.emit(false);\n          console.warn(\"error setting master mute\", err);\n        },\n        complete: () => {\n          console.log(\"complete\");\n        }\n      });\n      return ret;\n    }\n    setMixLevel(v, a, preset) {\n      const ret = new EventEmitter();\n      console.log(\"changing mix level to\", v, \"for audioDevice\", a);\n      const prev = a.mixlevel;\n      a.mixlevel = v;\n      const body = {\n        audioDevices: []\n      };\n      const vol = v * (preset.masterVolume / 100);\n      body.audioDevices.push({\n        name: a.name,\n        volume: Math.round(vol)\n      });\n      console.log(\"volume body\", body);\n      this.put(body).pipe(timeout(TIMEOUT), tap(res => console.log(\"PUT response\", res))).subscribe({\n        next: data => {\n          const event = new Event();\n          event.User = APIService.piHostname;\n          event.EventTags = [\"ui-communication\"];\n          event.AffectedRoom = new BasicRoomInfo(APIService.building + \"-\" + APIService.roomName);\n          event.TargetDevice = new BasicDeviceInfo(APIService.building + \"-\" + APIService.roomName + \"-\" + preset.name);\n          event.Key = \"mix-level\";\n          event.Value = String(v);\n          this.api.sendEvent(event);\n          ret.emit(true);\n          console.log(\"next\", data);\n        },\n        error: err => {\n          a.mixlevel = prev;\n          ret.emit(false);\n          console.warn(\"error setting mix level\", err);\n        },\n        complete: () => {\n          console.log(\"complete\");\n        }\n      });\n      return ret;\n    }\n    setMixMute(m, a, preset) {\n      const ret = new EventEmitter();\n      console.log(\"changing mix mute to\", m, \"for audioDevice\", a);\n      console.log(\"preset.masterMute is:\", preset.masterMute);\n      const prev = a.mixmute;\n      a.mixmute = m;\n      const body = {\n        audioDevices: []\n      };\n      body.audioDevices.push({\n        name: a.name,\n        muted: m\n      });\n      console.log(\"mix mute body:\", body);\n      this.put(body).pipe(timeout(TIMEOUT), tap(res => console.log(\"PUT response\", res))).subscribe({\n        next: data => {\n          const event = new Event();\n          event.User = APIService.piHostname;\n          event.EventTags = [\"ui-communication\"];\n          event.AffectedRoom = new BasicRoomInfo(APIService.building + \"-\" + APIService.roomName + \"-\" + preset.name);\n          event.Key = \"mix-mute\";\n          event.Value = String(m);\n          event.Data = preset.name;\n          this.api.sendEvent(event);\n          ret.emit(true);\n          console.log(\"next\", data);\n        },\n        error: err => {\n          a.mixmute = prev;\n          ret.emit(false);\n          console.warn(\"error setting mix mute\", err);\n        },\n        complete: () => {\n          console.log(\"complete\");\n        }\n      });\n      return ret;\n    }\n    powerOnDefault(preset) {\n      const ret = new EventEmitter();\n      const body = {\n        displays: [],\n        audioDevices: []\n      };\n      for (const d of preset.displays) {\n        body.displays.push({\n          name: d.name,\n          power: \"on\",\n          input: preset.inputs[0].name,\n          blanked: false\n        });\n      }\n      for (const a of preset.audioDevices) {\n        body.audioDevices.push({\n          name: a.name,\n          muted: false,\n          volume: 30\n        });\n      }\n      preset.masterMute = false;\n      console.log(\"sending power on default body\", body);\n      const powerOnReq = new CommandRequest(new HttpRequest(\"PUT\", APIService.apiurl, body));\n      const requests = [powerOnReq];\n      if (preset.commands.powerOn != null) {\n        for (const cmd of preset.commands.powerOn) {\n          requests.push(this.buildRequest(cmd));\n        }\n      }\n      if (preset.commands.inputSame) {\n        for (const cmd of preset.commands.inputSame) {\n          requests.push(this.buildRequest(cmd));\n        }\n      }\n      this.executeRequests(requests, 1, 20 * 1000).subscribe(success => {\n        ret.emit(success);\n      });\n      return ret;\n    }\n    executeRequests(requests, maxTries, timeout) {\n      const ret = new EventEmitter();\n      if (requests.length < 1) {\n        setTimeout(() => ret.emit(false), 250);\n        return ret;\n      }\n      console.info(\"executing requests: \", requests);\n      const numRequests = requests.length;\n      const mapToStatus = new Map();\n      for (const req of requests) {\n        this.executeRequest(req, maxTries, timeout).subscribe(success => {\n          mapToStatus.set(req, success);\n          if (mapToStatus.size === numRequests) {\n            console.info(\"finished all requests, requests => success:\", mapToStatus);\n            let allsuccessful = true;\n            mapToStatus.forEach((v, k) => {\n              if (!v) {\n                allsuccessful = false;\n              }\n            });\n            ret.emit(allsuccessful);\n            return;\n          }\n        });\n      }\n      console.log(\"waiting for\", requests.length, \"responses...\");\n      return ret;\n    }\n    executeRequest(req, maxTries, timeOut) {\n      const ret = new EventEmitter();\n      console.log(\"executing request\", req);\n      setTimeout(() => {\n        this.http.request(req.req).pipe(timeout(timeOut), catchError(this.handleError(\"executeRequest\", []))).subscribe({\n          next: data => {\n            console.log(\"successfully executed request\", req);\n            ret.emit(true);\n            return;\n          },\n          error: err => {\n            maxTries--;\n            if (maxTries === 0) {\n              ret.emit(false);\n              return;\n            }\n            // retry request\n            console.error(\"request (\" + req + \") failed. error:\", err, \". There are\", maxTries, \" remaining, retrying in 3 seconds...\");\n            setTimeout(() => this.executeRequest(req, maxTries, timeOut), 3000);\n          },\n          complete: () => {\n            console.log(\"complete\");\n          }\n        });\n      }, req.delay);\n      return ret;\n    }\n    buildRequest(cmd) {\n      // if we needed logic to create a request, it would be right here!!\n      return new CommandRequest(new HttpRequest(cmd.method, APIService.apihost + \":\" + cmd.port + \"/\" + cmd.endpoint, cmd.body), cmd.delay);\n    }\n    powerOff(preset) {\n      const ret = new EventEmitter();\n      const body = {\n        displays: [],\n        audioDevices: []\n      };\n      for (const d of preset.displays) {\n        body.displays.push({\n          name: d.name,\n          power: \"standby\",\n          input: preset.inputs[0].name\n        });\n      }\n      console.log(\"sending power off body\", body);\n      const powerOffReq = new CommandRequest(new HttpRequest(\"PUT\", APIService.apiurl, body));\n      const requests = [powerOffReq];\n      if (preset.commands.powerOff != null) {\n        for (const cmd of preset.commands.powerOff) {\n          requests.push(this.buildRequest(cmd));\n        }\n      }\n      this.executeRequests(requests, 1, 20 * 1000).subscribe(success => {\n        ret.emit(success);\n      });\n      return ret;\n    }\n    powerOffAll() {\n      const ret = new EventEmitter();\n      const body = {\n        power: \"standby\"\n      };\n      this.put(body).pipe(timeout(20 * 1000), catchError(this.handleError(\"powerOffAll\", []))).subscribe({\n        next: data => {\n          ret.emit(true);\n          console.log(\"power off all success\", data);\n        },\n        error: err => {\n          ret.emit(false);\n          console.error(\"power off all error\", err);\n        },\n        complete: () => {\n          console.log(\"power off all complete\");\n        }\n      });\n      return ret;\n    }\n    /*\n    public share(from: Display, to: Display[]): EventEmitter<boolean> {\n      const ret: EventEmitter<boolean> = new EventEmitter<boolean>();\n      if (from.input == null) {\n        setTimeout(() => ret.emit(false), 150);\n        return ret;\n      }\n         console.log(\"sharing to\", to, \"from\", from);\n         const body = { displays: [], audioDevices: [] };\n      for (const d of to) {\n        body.displays.push({\n          name: d.name,\n          power: \"on\",\n          blanked: false,\n          input: from.input.name\n        });\n      }\n         const audioConfigs = this.data.getAudioConfigurations(to);\n      const hasRoomWide = this.data.hasRoomWide(audioConfigs);\n         if (hasRoomWide) {\n        // mute the source device (yourself)\n        body.audioDevices.push({\n          name: from.name,\n          muted: true,\n          volume: 0\n        });\n           for (const config of audioConfigs) {\n          for (const audio of config.audioDevices) {\n            body.audioDevices.push({\n              name: audio.name,\n              muted: !config.roomWide,\n              volume: config.roomWide ? 30 : 0\n            });\n          }\n        }\n      } else {\n        // mute everything except for yourself\n        for (const config of audioConfigs) {\n          for (const audio of config.audioDevices) {\n            body.audioDevices.push({\n              name: audio.name,\n              muted: true,\n              volume: 0\n            });\n          }\n        }\n      }\n         console.log(\"share body:\", body);\n         this.putWithCustomTimeout(body, 20 * 1000).subscribe(\n        data => {\n          ret.emit(true);\n        },\n        err => {\n          ret.emit(false);\n        }\n      );\n         return ret;\n    }\n       public unShare(\n      from: Display[],\n      fromAudio: AudioConfig[]\n    ): EventEmitter<boolean> {\n      const ret: EventEmitter<boolean> = new EventEmitter<boolean>();\n      const body = { displays: [], audioDevices: [] };\n         for (const d of from) {\n        const preset: Preset = this.data.presets.find(p =>\n          p.displays.includes(d)\n        );\n           if (preset != null) {\n          body.displays.push({\n            name: d.name,\n            power: \"on\",\n            input: preset.inputs[0].name,\n            blanked: false\n          });\n        }\n      }\n         for (const ac of fromAudio) {\n        for (const a of ac.audioDevices) {\n          body.audioDevices.push({\n            name: a.name,\n            volume: 30,\n            muted: false\n          });\n        }\n      }\n         console.log(\"unshare body\", body);\n         this.putWithCustomTimeout(body, 20 * 1000).subscribe(\n        data => {\n          ret.emit(true);\n        },\n        err => {\n          ret.emit(false);\n        }\n      );\n         return ret;\n    }\n       public mirror(mirror: Preset, on: Preset) {\n      const ret: EventEmitter<boolean> = new EventEmitter<boolean>();\n      const body = { displays: [], audioDevices: [] };\n         const power: string = Display.getPower(mirror.displays);\n      const input: Input = Display.getInput(mirror.displays);\n      const blanked: boolean = Display.getBlank(mirror.displays);\n         for (const d of on.displays) {\n        body.displays.push({\n          name: d.name,\n          power: power,\n          input: input.name,\n          blanked: blanked\n        });\n      }\n         for (const a of on.audioDevices) {\n        body.audioDevices.push({\n          name: a.name,\n          muted: true\n        });\n      }\n         this.put(body).subscribe(\n        data => {\n          ret.emit(true);\n        },\n        err => {\n          ret.emit(false);\n        }\n      );\n         return ret;\n    }\n       */\n    viaControl(via, endpoint) {\n      const ret = new EventEmitter();\n      // get the address of the via\n      const config = this.data.getInputConfiguration(via);\n      // build the request\n      const req = new HttpRequest(\"GET\", APIService.apihost + \":8014/via/\" + config.address + \"/\" + endpoint);\n      // execute request\n      console.log(\"executing via control request:\", req);\n      this.http.request(req).pipe(timeout(20 * 1000), catchError(this.handleError(\"viaControl\", []))).subscribe({\n        next: data => {\n          ret.emit(true);\n          console.log(\"via control success\", data);\n        },\n        error: err => {\n          ret.emit(false);\n          console.error(\"via control error\", err);\n        },\n        complete: () => {\n          console.log(\"via control complete\");\n        }\n      });\n      return ret;\n    }\n    buttonPress(value, data) {\n      const event = new Event();\n      event.EventTags = [\"ui-event\", \"cherry-ui\"];\n      event.AffectedRoom = new BasicRoomInfo(APIService.building + \"-\" + APIService.roomName);\n      event.TargetDevice = new BasicDeviceInfo(APIService.piHostname);\n      event.GeneratingSystem = APIService.piHostname;\n      event.Timestamp = new Date();\n      event.User = \"\";\n      event.Data = data;\n      event.Key = \"user-interaction\";\n      event.Value = value;\n      this.api.sendEvent(event);\n    }\n    handleError(operation = \"operation\", result) {\n      return error => {\n        console.error(\"error doing ${operation}\", error);\n        return of(result);\n      };\n    }\n  }\n  _class2 = CommandService;\n  _defineProperty(CommandService, \"\\u0275fac\", function CommandService_Factory(t) {\n    return new (t || _class2)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.DataService), i0.ɵɵinject(i3.APIService), i0.ɵɵinject(i4.MatDialog));\n  });\n  _defineProperty(CommandService, \"\\u0275prov\", /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _class2,\n    factory: _class2.ɵfac\n  }));\n  return CommandService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
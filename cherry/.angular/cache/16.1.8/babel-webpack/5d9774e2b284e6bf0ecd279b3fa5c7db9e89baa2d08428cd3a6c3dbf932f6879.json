{"ast":null,"code":"\"use strict\";\n\nvar rxjs_1 = require('rxjs');\nvar $WebSocket = function () {\n  function $WebSocket(url, protocols, config, binaryType) {\n    this.url = url;\n    this.protocols = protocols;\n    this.config = config;\n    this.binaryType = binaryType;\n    this.reconnectAttempts = 0;\n    this.sendQueue = [];\n    this.onOpenCallbacks = [];\n    this.onMessageCallbacks = [];\n    this.onErrorCallbacks = [];\n    this.onCloseCallbacks = [];\n    this.readyStateConstants = {\n      'UNINITIALIZED': -1,\n      'CONNECTING': 0,\n      'OPEN': 1,\n      'CLOSING': 2,\n      'CLOSED': 3,\n      'RECONNECT_ABORTED': 4\n    };\n    this.normalCloseCode = 1000;\n    this.reconnectableStatusCodes = [4000];\n    this.send4Mode = WebSocketSendMode.Observable;\n    var match = new RegExp('wss?:\\/\\/').test(url);\n    if (!match) {\n      throw new Error('Invalid url provided');\n    }\n    this.config = Object.assign({\n      initialTimeout: 500,\n      maxTimeout: 300000,\n      reconnectIfNotNormalClose: false\n    }, config);\n    this.binaryType = binaryType || 'blob';\n    this.dataStream = new rxjs_1.Subject();\n    this.errorMessages = new rxjs_1.Subject();\n    this.connect(true);\n  }\n  $WebSocket.prototype.connect = function (force) {\n    var _this = this;\n    if (force === void 0) {\n      force = false;\n    }\n    // console.log(\"WebSocket connecting...\");\n    var self = this;\n    if (force || !this.socket || this.socket.readyState !== this.readyStateConstants.OPEN) {\n      self.socket = this.protocols ? new WebSocket(this.url, this.protocols) : new WebSocket(this.url);\n      self.socket.binaryType = self.binaryType;\n      self.socket.onopen = function (ev) {\n        // console.log('onOpen: ', ev);\n        _this.onOpenHandler(ev);\n      };\n      self.socket.onmessage = function (ev) {\n        // console.log('onNext: ', ev.data);\n        self.onMessageHandler(ev);\n        _this.dataStream.next(ev);\n      };\n      this.socket.onclose = function (ev) {\n        // console.log('onClose ', ev);\n        self.onCloseHandler(ev);\n      };\n      this.socket.onerror = function (ev) {\n        // console.log('onError ', ev);\n        self.onErrorHandler(ev);\n        _this.errorMessages.next(ev);\n      };\n    }\n  };\n  $WebSocket.prototype.getErrorStream = function () {\n    return this.errorMessages;\n  };\n  /**\n   * Run in Block Mode\n   * Return true when can send and false in socket closed\n   * @param data\n   * @returns {boolean}\n   */\n  $WebSocket.prototype.send4Direct = function (data, binary) {\n    var self = this;\n    if (this.getReadyState() !== this.readyStateConstants.OPEN && this.getReadyState() !== this.readyStateConstants.CONNECTING) {\n      this.connect();\n    }\n    self.sendQueue.push({\n      message: data,\n      binary: binary\n    });\n    if (self.socket.readyState === self.readyStateConstants.OPEN) {\n      self.fireQueue();\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * Return Promise\n   * When can Send will resolve Promise\n   * When Socket closed will reject Promise\n   * @param data\n   * @returns {Promise<any>}\n   */\n  $WebSocket.prototype.send4Promise = function (data, binary) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      if (_this.send4Direct(data, binary)) {\n        return resolve();\n      } else {\n        return reject(Error('Socket connection has been closed'));\n      }\n    });\n  };\n  /**\n   * Return cold Observable\n   * When can Send will complete observer\n   * When Socket closed will error observer\n   * @param data\n   * @returns {Observable<any>}\n   */\n  $WebSocket.prototype.send4Observable = function (data, binary) {\n    var _this = this;\n    return rxjs_1.Observable.create(function (observer) {\n      if (_this.send4Direct(data, binary)) {\n        return observer.complete();\n      } else {\n        return observer.error('Socket connection has been closed');\n      }\n    });\n  };\n  /**\n   * Set send(data) function return mode\n   * @param mode\n   */\n  $WebSocket.prototype.setSend4Mode = function (mode) {\n    this.send4Mode = mode;\n  };\n  /**\n   * Use {mode} mode to send {data} data\n   * If no specify, Default SendMode is Observable mode\n   * @param data\n   * @param mode\n   * @param binary\n   * @returns {any}\n   */\n  $WebSocket.prototype.send = function (data, mode, binary) {\n    switch (typeof mode !== 'undefined' ? mode : this.send4Mode) {\n      case WebSocketSendMode.Direct:\n        return this.send4Direct(data, binary);\n      case WebSocketSendMode.Promise:\n        return this.send4Promise(data, binary);\n      case WebSocketSendMode.Observable:\n        return this.send4Observable(data, binary);\n      default:\n        throw Error('WebSocketSendMode Error.');\n    }\n  };\n  $WebSocket.prototype.getDataStream = function () {\n    return this.dataStream;\n  };\n  $WebSocket.prototype.onOpenHandler = function (event) {\n    this.reconnectAttempts = 0;\n    this.notifyOpenCallbacks(event);\n    this.fireQueue();\n  };\n  $WebSocket.prototype.notifyOpenCallbacks = function (event) {\n    for (var i = 0; i < this.onOpenCallbacks.length; i++) {\n      this.onOpenCallbacks[i].call(this, event);\n    }\n  };\n  $WebSocket.prototype.fireQueue = function () {\n    // console.log(\"fireQueue()\");\n    while (this.sendQueue.length && this.socket.readyState === this.readyStateConstants.OPEN) {\n      var data = this.sendQueue.shift();\n      // console.log(\"fireQueue: \", data);\n      if (data.binary) {\n        this.socket.send(data.message);\n      } else {\n        this.socket.send($WebSocket.Helpers.isString(data.message) ? data.message : JSON.stringify(data.message));\n      }\n    }\n  };\n  $WebSocket.prototype.notifyCloseCallbacks = function (event) {\n    for (var i = 0; i < this.onCloseCallbacks.length; i++) {\n      this.onCloseCallbacks[i].call(this, event);\n    }\n  };\n  $WebSocket.prototype.notifyErrorCallbacks = function (event) {\n    for (var i = 0; i < this.onErrorCallbacks.length; i++) {\n      this.onErrorCallbacks[i].call(this, event);\n    }\n  };\n  $WebSocket.prototype.onOpen = function (cb) {\n    this.onOpenCallbacks.push(cb);\n    return this;\n  };\n  ;\n  $WebSocket.prototype.onClose = function (cb) {\n    this.onCloseCallbacks.push(cb);\n    return this;\n  };\n  $WebSocket.prototype.onError = function (cb) {\n    this.onErrorCallbacks.push(cb);\n    return this;\n  };\n  ;\n  $WebSocket.prototype.onMessage = function (callback, options) {\n    if (!$WebSocket.Helpers.isFunction(callback)) {\n      throw new Error('Callback must be a function');\n    }\n    this.onMessageCallbacks.push({\n      fn: callback,\n      pattern: options ? options.filter : undefined,\n      autoApply: options ? options.autoApply : true\n    });\n    return this;\n  };\n  $WebSocket.prototype.onMessageHandler = function (message) {\n    var self = this;\n    var currentCallback;\n    for (var i = 0; i < self.onMessageCallbacks.length; i++) {\n      currentCallback = self.onMessageCallbacks[i];\n      currentCallback.fn.apply(self, [message]);\n    }\n  };\n  ;\n  $WebSocket.prototype.onCloseHandler = function (event) {\n    this.notifyCloseCallbacks(event);\n    if (this.config.reconnectIfNotNormalClose && event.code !== this.normalCloseCode || this.reconnectableStatusCodes.indexOf(event.code) > -1) {\n      this.reconnect();\n    } else {\n      this.sendQueue = [];\n      this.dataStream.complete();\n    }\n  };\n  ;\n  $WebSocket.prototype.onErrorHandler = function (event) {\n    this.notifyErrorCallbacks(event);\n  };\n  ;\n  $WebSocket.prototype.reconnect = function () {\n    var _this = this;\n    this.close(true, true);\n    var backoffDelay = this.getBackoffDelay(++this.reconnectAttempts);\n    // let backoffDelaySeconds = backoffDelay / 1000;\n    // console.log('Reconnecting in ' + backoffDelaySeconds + ' seconds');\n    setTimeout(function () {\n      if (_this.config.reconnectIfNotNormalClose) {\n        _this.connect();\n      }\n    }, backoffDelay);\n    return this;\n  };\n  $WebSocket.prototype.close = function (force, keepReconnectIfNotNormalClose) {\n    if (force === void 0) {\n      force = false;\n    }\n    if (!keepReconnectIfNotNormalClose) {\n      this.config.reconnectIfNotNormalClose = false;\n    }\n    if (force || !this.socket.bufferedAmount) {\n      this.socket.close(this.normalCloseCode);\n    }\n    return this;\n  };\n  ;\n  // Exponential Backoff Formula by Prof. Douglas Thain\n  // http://dthain.blogspot.co.uk/2009/02/exponential-backoff-in-distributed.html\n  $WebSocket.prototype.getBackoffDelay = function (attempt) {\n    var R = Math.random() + 1;\n    var T = this.config.initialTimeout;\n    var F = 2;\n    var N = attempt;\n    var M = this.config.maxTimeout;\n    return Math.floor(Math.min(R * T * Math.pow(F, N), M));\n  };\n  ;\n  $WebSocket.prototype.setInternalState = function (state) {\n    if (Math.floor(state) !== state || state < 0 || state > 4) {\n      throw new Error('state must be an integer between 0 and 4, got: ' + state);\n    }\n    this.internalConnectionState = state;\n  };\n  $WebSocket.prototype.getReadyState = function () {\n    if (this.socket == null) {\n      return this.readyStateConstants.UNINITIALIZED;\n    }\n    return this.internalConnectionState || this.socket.readyState;\n  };\n  $WebSocket.Helpers = function () {\n    function class_1() {}\n    class_1.isPresent = function (obj) {\n      return obj !== undefined && obj !== null;\n    };\n    class_1.isString = function (obj) {\n      return typeof obj === 'string';\n    };\n    class_1.isArray = function (obj) {\n      return Array.isArray(obj);\n    };\n    class_1.isFunction = function (obj) {\n      return typeof obj === 'function';\n    };\n    return class_1;\n  }();\n  return $WebSocket;\n}();\nexports.$WebSocket = $WebSocket;\n(function (WebSocketSendMode) {\n  WebSocketSendMode[WebSocketSendMode[\"Direct\"] = 0] = \"Direct\";\n  WebSocketSendMode[WebSocketSendMode[\"Promise\"] = 1] = \"Promise\";\n  WebSocketSendMode[WebSocketSendMode[\"Observable\"] = 2] = \"Observable\";\n})(exports.WebSocketSendMode || (exports.WebSocketSendMode = {}));\nvar WebSocketSendMode = exports.WebSocketSendMode;\n//# sourceMappingURL=angular2-websocket.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}
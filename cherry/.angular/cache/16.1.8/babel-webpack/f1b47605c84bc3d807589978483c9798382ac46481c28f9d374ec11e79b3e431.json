{"ast":null,"code":"import _defineProperty from \"/home/orcrist/Desktop/touchpanel-ui-microservice/cherry/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { EventEmitter } from \"@angular/core\";\nimport { APIService } from \"../services/api.service\";\nexport const POWER = \"power\";\nexport const INPUT = \"input\";\nexport const BLANKED = \"blanked\";\nexport const MUTED = \"muted\";\nexport const VOLUME = \"volume\";\nexport class Device {\n  constructor(name, displayname, icon) {\n    _defineProperty(this, \"name\", void 0);\n    _defineProperty(this, \"displayname\", void 0);\n    _defineProperty(this, \"icon\", void 0);\n    this.name = name;\n    this.displayname = displayname;\n    this.icon = icon;\n  }\n  static filterDevices(names, devices) {\n    if (names == null || devices == null) {\n      return [];\n    }\n    const ret = [];\n    for (const name of names) {\n      const dev = devices.find(d => d.name === name);\n      if (dev != null) {\n        ret.push(dev);\n      }\n    }\n    return ret;\n  }\n  static getDeviceByName(name, devices) {\n    if (name == null || devices == null) {\n      return null;\n    }\n    for (const d of devices) {\n      if (d.name === name) {\n        return d;\n      }\n    }\n    return null;\n  }\n  getName() {\n    return this.name;\n  }\n  getDisplayName() {\n    return this.displayname;\n  }\n  getIcon() {\n    return this.icon;\n  }\n}\nexport class Input extends Device {\n  constructor(name, displayname, icon, subs) {\n    super(name, displayname, icon);\n    _defineProperty(this, \"click\", new EventEmitter());\n    _defineProperty(this, \"subInputs\", []);\n    this.subInputs = subs;\n  }\n  static getInput(name, inputs) {\n    for (const i of inputs) {\n      if (i.name === name) {\n        return i;\n      }\n      if (i.subInputs !== undefined && i.subInputs.length > 0) {\n        for (const sub of i.subInputs) {\n          if (sub.name === name) {\n            return sub;\n          }\n        }\n      }\n    }\n  }\n}\nexport class Output extends Device {\n  static getPower(outputs) {\n    for (const o of outputs) {\n      if (o.power === \"on\") {\n        return o.power;\n      }\n    }\n    return \"standby\";\n  }\n  static isPoweredOn(outputs) {\n    for (const o of outputs) {\n      if (o.power !== \"on\") {\n        return false;\n      }\n    }\n    return true;\n  }\n  static getInput(outputs) {\n    let input = null;\n    for (const o of outputs) {\n      if (input == null) {\n        input = o.input;\n      } else if (o.input !== input) {\n        // this means the input that appears selected may not actually be selected on all displays.\n        // to get the ~correct~ behavior, return null.\n        return o.input;\n      }\n    }\n    return input;\n  }\n  static setPower(s, outputs) {\n    outputs.forEach(o => o.power = s);\n  }\n  static setInput(i, outputs) {\n    outputs.forEach(o => o.input = i);\n  }\n  constructor(name, displayname, power, input, icon) {\n    super(name, displayname, icon);\n    _defineProperty(this, \"power\", void 0);\n    _defineProperty(this, \"input\", void 0);\n    _defineProperty(this, \"powerEmitter\", void 0);\n    this.power = power;\n    this.input = input;\n    this.powerEmitter = new EventEmitter();\n  }\n  getInputIcon() {\n    if (this.input == null) {\n      return this.icon;\n    }\n    return this.input.icon;\n  }\n}\nexport class Display extends Output {\n  static getDisplayListFromNames(names, displaysSource) {\n    return displaysSource.filter(d => names.includes(d.name));\n  }\n  constructor(name, displayname, power, input, blanked, icon, hidden) {\n    super(name, displayname, power, input, icon);\n    _defineProperty(this, \"blanked\", void 0);\n    _defineProperty(this, \"hidden\", void 0);\n    this.blanked = blanked;\n    this.hidden = hidden;\n  }\n  // returns true iff all are blanked\n  static getBlank(displays) {\n    for (const d of displays) {\n      if (!d.blanked) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static setBlank(b, displays) {\n    displays.forEach(d => d.blanked = b);\n  }\n  getAudioConfiguration() {\n    return APIService.room.uiconfig.audioConfiguration.find(a => a.display === this.name);\n  }\n}\nexport class AudioDevice extends Output {\n  constructor(name, displayname, power, input, muted, volume, icon, type, mixlevel) {\n    super(name, displayname, power, input, icon);\n    _defineProperty(this, \"muted\", void 0);\n    _defineProperty(this, \"volume\", void 0);\n    _defineProperty(this, \"type\", void 0);\n    _defineProperty(this, \"mixlevel\", void 0);\n    _defineProperty(this, \"mixmute\", void 0);\n    this.muted = muted;\n    this.volume = volume;\n    this.type = type;\n    this.mixlevel = mixlevel;\n  }\n  // return average of all volumes\n  static getVolume(audioDevices) {\n    if (audioDevices == null) {\n      return 0;\n    }\n    let volume = 0;\n    audioDevices.forEach(a => volume += a.volume);\n    return volume / audioDevices.length;\n  }\n  // returns true iff both are muted\n  static getMute(audioDevices) {\n    if (audioDevices == null) {\n      return false;\n    }\n    for (const a of audioDevices) {\n      if (!a.muted) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static setVolume(v, audioDevices) {\n    audioDevices.forEach(a => a.volume = v);\n  }\n  static setMute(m, audioDevices) {\n    audioDevices.forEach(a => a.muted = m);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
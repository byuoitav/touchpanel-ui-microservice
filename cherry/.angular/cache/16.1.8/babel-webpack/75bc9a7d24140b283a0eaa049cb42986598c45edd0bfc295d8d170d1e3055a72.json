{"ast":null,"code":"import _defineProperty from \"/home/orcrist/Desktop/touchpanel-ui-microservice/cherry/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { EventEmitter } from \"@angular/core\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { APIService } from \"./api.service\";\nimport { DataService } from \"./data.service\";\nimport { SocketService, MESSAGE } from \"./socket.service\";\nimport { map, tap, of, catchError } from \"rxjs\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./data.service\";\nimport * as i2 from \"./socket.service\";\nimport * as i3 from \"@angular/common/http\";\n/*\n *\n *  When the GraphService recieves an event from a Pi that is monitoring contact points,\n *      it will find the node who's display field matches the full set of displays on one half\n *      of the eventInfoValue (shown below). Once it finds that node (1), it will create a new node (2) with\n *      displays equal to the other half of the eventInfoValue as a child of the node (1).\n *\n *  The HomeComponent will use the GraphService to decide which names to show when a user presses share.\n *\n *  An example event from the contact-point monitioring pi is:\n *  {\n *      eventInfoKey:   'OPENED',\n *      eventInfoValue: 'D4,D5,D6/D7,D8,D9'\n *  }\n */\nconst CONNECT = \"connect\";\nconst DISCONNECT = \"disconnect\";\nconst LEFT_RIGHT_DELIMITER = \"/\";\nconst DISPLAY_DELIMITER = \",\";\nexport let GraphService = /*#__PURE__*/(() => {\n  var _class;\n  class GraphService {\n    constructor(data, socket, http) {\n      _defineProperty(this, \"data\", void 0);\n      _defineProperty(this, \"socket\", void 0);\n      _defineProperty(this, \"http\", void 0);\n      _defineProperty(this, \"displayList\", void 0);\n      _defineProperty(this, \"root\", void 0);\n      _defineProperty(this, \"exists\", false);\n      _defineProperty(this, \"nodes\", []);\n      _defineProperty(this, \"dividerSensor\", void 0);\n      this.data = data;\n      this.socket = socket;\n      this.http = http;\n      this.displayList = new EventEmitter();\n      this.data.loaded.subscribe(() => {\n        this.init();\n      });\n    }\n    init() {\n      if (this.exists) {\n        return;\n      }\n      if (this.data.panel.preset.shareableDisplays == null) {\n        return;\n      }\n      // the root node is the set of displays and shareableDisplays for the preset\n      const displays = new Set();\n      this.data.panel.preset.displays.forEach(d => displays.add(d.name));\n      this.data.panel.preset.shareableDisplays.forEach(d => displays.add(d));\n      this.root = new Node(displays);\n      this.nodes.push(this.root);\n      this.exists = true;\n      // get the current connected/disconnected state\n      this.dividerSensor = APIService.room.config.devices.find(d => d.hasRole(\"DividerSensor\"));\n      console.log(\"dividerSensor\", this.dividerSensor);\n      if (this.dividerSensor != null) {\n        /* cherry doesn't need to do this? it doesn't do sharing\n        this.getDividerSensorStatus();\n        this.update();\n               // set the current preset if necessary\n        if (this.data.panel.features.includes(PRESET_SWITCH)) {\n          this.setCurrentPreset();\n        }\n               console.log(\"root\", this.root);\n        */\n      } else {\n        console.warn(\"no divider sensor found. not listening for division events.\");\n      }\n    }\n    getDisplayList() {\n      const ret = new Set();\n      this.getdisplaylist(this.root, ret);\n      return ret;\n    }\n    /*\n     * recursivly descends through nodes and adds their displays to the list\n     */\n    getdisplaylist(node, list) {\n      let displays = Array.from(node.displays);\n      displays = displays.filter(d => !list.has(d));\n      if (displays.length > 0) {\n        displays.forEach(d => list.add(d));\n        for (const child of node.children) {\n          this.getdisplaylist(child, list);\n        }\n      }\n      return list;\n    }\n    /*\n     * gets the status of the room from the divider sensor.\n     * loops through the connected events and adds connected nodes until\n     * there isnt' a change in my displays.\n     *\n     * loops through the disconnected events and disconnects displays that may be disconnected.\n     *      TODO (?) is this necessary? or should i just assume they are disconnected.\n     */\n    getDividerSensorStatus() {\n      if (this.dividerSensor != null) {\n        this.http.get(\"http://\" + this.dividerSensor.address + \":10000/divider/state\").pipe(map(res => res), tap(res => console.log(\"getDividerSensorStatus\", res)), catchError(this.handleError(\"getDividerSensorStatus\", []))).subscribe({\n          next: data => {\n            if (data[\"connected\"] != null) {\n              let numChanged;\n              do {\n                numChanged = 0;\n                for (const connected of data[\"connected\"]) {\n                  if (this.connect(connected)) {\n                    ++numChanged;\n                  }\n                }\n              } while (numChanged > 0);\n            }\n            if (data[\"disconnected\"] != null) {\n              for (const disconnected of data[\"disconnected\"]) {\n                this.disconnect(disconnected);\n              }\n            }\n          },\n          error: err => {\n            setTimeout(this.getDividerSensorStatus, 5000);\n            console.warn(\"failed to get divider sensor status, trying again in 5 seconds\", err);\n          },\n          complete: () => {\n            console.log(\"completed getting divider sensor status\");\n          }\n        });\n      }\n    }\n    setCurrentPreset() {\n      this.http.get(\"http://\" + this.dividerSensor.address + \":10000/divider/preset/\" + APIService.piHostname).pipe(map(res => res), tap(res => console.log(\"setCurrentPreset\", res)), catchError(this.handleError(\"setCurrentPreset\", []))).subscribe({\n        next: data => {\n          const preset = this.data.presets.find(p => p.name.toLowerCase() === data.toString().toLowerCase());\n          if (preset != null) {\n            console.log(\"setting initial preset to\", preset);\n            this.data.panel.preset = preset;\n          } else {\n            console.error(\"current preset response doesn't exist. response: \", data);\n          }\n        },\n        error: err => {\n          console.warn(\"failed to get intial preset from divider sensor, trying again...\", err);\n          setTimeout(this.setCurrentPreset, 5000);\n        },\n        complete: () => {\n          console.log(\"completed setting current preset\");\n        }\n      });\n    }\n    getNodeByDisplays(list) {\n      const l = JSON.stringify(Array.from(list));\n      return this.nodes.find(n => JSON.stringify(Array.from(n.displays)) === l);\n    }\n    connect(s) {\n      console.info(\"*connected* event:\", s);\n      const sides = s.split(LEFT_RIGHT_DELIMITER);\n      const left = new Set(sides[0].split(DISPLAY_DELIMITER));\n      const right = new Set(sides[1].split(DISPLAY_DELIMITER));\n      let changed = false;\n      let lnode = this.getNodeByDisplays(left);\n      let rnode = this.getNodeByDisplays(right);\n      if (lnode == null) {\n        lnode = new Node(left);\n        this.nodes.push(lnode);\n        console.log(\"created a new node\", lnode, \". nodes:\", this.nodes);\n      }\n      if (rnode == null) {\n        rnode = new Node(right);\n        this.nodes.push(rnode);\n        console.log(\"created a new node\", rnode, \". nodes:\", this.nodes);\n      }\n      if (!lnode.children.includes(rnode)) {\n        lnode.children.push(rnode);\n        changed = true;\n      }\n      if (!rnode.children.includes(lnode)) {\n        rnode.children.push(lnode);\n        changed = true;\n      }\n      if (changed) {\n        this.displayList.emit(this.getDisplayList());\n      }\n      return changed;\n    }\n    disconnect(s) {\n      console.info(\"*disconnected* event:\", s);\n      const sides = s.split(LEFT_RIGHT_DELIMITER);\n      const left = new Set(sides[0].split(DISPLAY_DELIMITER));\n      const right = new Set(sides[1].split(DISPLAY_DELIMITER));\n      let changed = false;\n      const lnode = this.getNodeByDisplays(left);\n      const rnode = this.getNodeByDisplays(right);\n      if (lnode == null || rnode == null) {\n        return false;\n      }\n      if (lnode.children.includes(rnode) || rnode.children.includes(lnode)) {\n        changed = true;\n        lnode.children = lnode.children.filter(n => n !== rnode);\n        rnode.children = rnode.children.filter(n => n !== lnode);\n      }\n      if (changed) {\n        this.displayList.emit(this.getDisplayList());\n      }\n      return changed;\n    }\n    update() {\n      this.displayList.emit(this.getDisplayList());\n      this.socket.getEventListener().subscribe(event => {\n        if (event.type === MESSAGE) {\n          const e = event.data;\n          switch (e.Key) {\n            case CONNECT:\n              this.connect(e.Value);\n              break;\n            case DISCONNECT:\n              this.disconnect(e.Value);\n              break;\n          }\n        }\n      });\n    }\n    handleError(operation = \"operation\", result) {\n      return error => {\n        console.error(\"error doing ${operation}\", error);\n        return of(result);\n      };\n    }\n  }\n  _class = GraphService;\n  _defineProperty(GraphService, \"\\u0275fac\", function GraphService_Factory(t) {\n    return new (t || _class)(i0.ɵɵinject(i1.DataService), i0.ɵɵinject(i2.SocketService), i0.ɵɵinject(i3.HttpClient));\n  });\n  _defineProperty(GraphService, \"\\u0275prov\", /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac\n  }));\n  return GraphService;\n})();\n/*\n *  Represents an array of displays that a preset can share to.\n */\nclass Node {\n  constructor(displays) {\n    _defineProperty(this, \"displays\", void 0);\n    _defineProperty(this, \"children\", []);\n    this.displays = displays;\n  }\n  matches(list) {\n    if (this.displays.size !== list.size) {\n      return false;\n    }\n    for (const d of Array.from(this.displays)) {\n      if (!list.has(d)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}
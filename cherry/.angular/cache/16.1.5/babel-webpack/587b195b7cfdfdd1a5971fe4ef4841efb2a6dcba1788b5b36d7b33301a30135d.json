{"ast":null,"code":"import { Any } from \"./any\";\nimport { OperationMode, PropertyConvertingMode, PropertyMatchingRule, ValueCheckingMode } from \"./json-convert-enums\";\nimport { Settings } from \"./json-convert-options\";\n/**\n * Offers a simple API for mapping JSON objects to TypeScript/JavaScript classes and vice versa.\n *\n * @see https://www.npmjs.com/package/json2typescript full documentation on NPM\n */\nvar JsonConvert = /** @class */function () {\n  /////////////////\n  // CONSTRUCTOR //\n  /////////////////\n  /**\n   * Constructor.\n   *\n   * To learn more about the params, check the documentation of the equally named class properties.\n   *\n   * @param operationMode optional param (default: OperationMode.ENABLE)\n   * @param valueCheckingMode optional param (default: ValueCheckingMode.ALLOW_OBJECT_NULL)\n   * @param ignorePrimitiveChecks optional param (default: false)\n   * @param propertyMatchingRule optional param (default: PropertyMatchingRule.CASE_STRICT)\n   */\n  function JsonConvert(operationMode, valueCheckingMode, ignorePrimitiveChecks, propertyMatchingRule) {\n    ////////////////\n    // PROPERTIES //\n    ////////////////\n    /**\n     * Determines how the JsonConvert class instance should operate.\n     *\n     * You may assign three different values:\n     * - OperationMode.DISABLE: json2typescript will be disabled, no type checking or mapping is done\n     * - OperationMode.ENABLE: json2typescript is enabled, but only errors are logged\n     * - OperationMode.LOGGING: json2typescript is enabled and detailed information is logged\n     */\n    this._operationMode = OperationMode.ENABLE;\n    /**\n     * Determines which types are allowed to be null.\n     * This setting may be overridden by property settings (see PropertyConvertingMode).\n     *\n     * You may assign three different values:\n     * - ValueCheckingMode.ALLOW_NULL: all given values are allowed to be null\n     * - ValueCheckingMode.ALLOW_OBJECT_NULL: objects are allowed to be null, primitive types are not allowed to be null\n     * - ValueCheckingMode.DISALLOW_NULL: no null values are tolerated\n     */\n    this._valueCheckingMode = ValueCheckingMode.ALLOW_OBJECT_NULL;\n    /**\n     * Determines whether a missing or undefined property value should be considered as null or not.\n     *\n     * If true, a missing JSON value will be added and set as null before deserialization.\n     * For serialization, undefined values will be set to null before serialization.\n     *\n     * The ValueCheckingMode and PropertyConvertingMode determine whether an error will be thrown during\n     * serialization or deserialization.\n     */\n    this._mapUndefinedToNull = false;\n    /**\n     * Determines whether primitive types should be checked.\n     * If true, it will be allowed to assign primitive to other primitive types.\n     */\n    this._ignorePrimitiveChecks = false;\n    /**\n     * Determines the rule of how JSON properties shall be matched with class properties during deserialization.\n     *\n     * You may assign the following values:\n     * - PropertyMatchingRule.CASE_STRICT: JSON properties need to match exactly the names in the decorators\n     * - PropertyMatchingRule.CASE_INSENSITIVE: JSON properties need to match names in the decorators, but names they\n     * are not case sensitive\n     */\n    this._propertyMatchingRule = PropertyMatchingRule.CASE_STRICT;\n    /**\n     * Determines how nullable property types should be serialized and deserialized.\n     * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n     *\n     * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n     *\n     * The values should be used as follows:\n     * Determines how nullable property types should be serialized and deserialized.\n     * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n     *\n     * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n     *\n     * The values should be used as follows:\n     * - MAP_NULLABLE: the mapper is applied, type is checked\n     * - IGNORE_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * not added to the result\n     * - PASS_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * added with its value to the result\n     */\n    this._propertyConvertingMode = undefined;\n    /**\n     * Determines if discriminators should be used.\n     * If this option is set to true, all registered classes will be serialized with an additional discriminator\n     * property (default: \"$type\"), which has the key of the class (given in the @JsonObject decorator) as value.\n     * When deserializing an object containing the discriminator property, json2typescript will attempt to\n     * automatically instantiate the correct type (by comparing the value of the discriminator property with the\n     * registered classes).\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    this._useDiscriminator = false;\n    /**\n     * Defines the name of the discriminator property.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    this._discriminatorPropertyName = \"$type\";\n    /**\n     * Determines all classes which should use the lazy-loading or discriminator feature.\n     * Only classes provided here can be used with lazy-loading or the discriminator property.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    this._classes = new Map();\n    if (operationMode !== undefined && operationMode in OperationMode) this.operationMode = operationMode;\n    if (valueCheckingMode !== undefined && valueCheckingMode in ValueCheckingMode) this.valueCheckingMode = valueCheckingMode;\n    if (ignorePrimitiveChecks !== undefined) this.ignorePrimitiveChecks = ignorePrimitiveChecks;\n    if (propertyMatchingRule !== undefined) this.propertyMatchingRule = propertyMatchingRule;\n  }\n  Object.defineProperty(JsonConvert.prototype, \"operationMode\", {\n    /**\n     * Determines how the JsonConvert class instance should operate.\n     *\n     * You may assign three different values:\n     * - OperationMode.DISABLE: json2typescript will be disabled, no type checking or mapping is done\n     * - OperationMode.ENABLE: json2typescript is enabled, but only errors are logged\n     * - OperationMode.LOGGING: json2typescript is enabled and detailed information is logged\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._operationMode;\n    },\n    /**\n     * Determines how the JsonConvert class instance should operate.\n     *\n     * You may assign three different values:\n     * - OperationMode.DISABLE: json2typescript will be disabled, no type checking or mapping is done\n     * - OperationMode.ENABLE: json2typescript is enabled, but only errors are logged\n     * - OperationMode.LOGGING: json2typescript is enabled and detailed information is logged\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      if (value in OperationMode) this._operationMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"valueCheckingMode\", {\n    /**\n     * Determines which types are allowed to be null.\n     * This setting may be overridden by property settings (see PropertyConvertingMode).\n     *\n     * You may assign three different values:\n     * - ValueCheckingMode.ALLOW_NULL: all given values are allowed to be null\n     * - ValueCheckingMode.ALLOW_OBJECT_NULL: objects are allowed to be null, primitive types are not allowed to be null\n     * - ValueCheckingMode.DISALLOW_NULL: no null values are tolerated\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._valueCheckingMode;\n    },\n    /**\n     * Determines which types are allowed to be null.\n     * This setting may be overridden by property settings (see PropertyConvertingMode).\n     *\n     * You may assign three different values:\n     * - ValueCheckingMode.ALLOW_NULL: all given values are allowed to be null\n     * - ValueCheckingMode.ALLOW_OBJECT_NULL: objects are allowed to be null, primitive types are not allowed to be null\n     * - ValueCheckingMode.DISALLOW_NULL: no null values are tolerated\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      if (value in ValueCheckingMode) this._valueCheckingMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"mapUndefinedToNull\", {\n    /**\n     * Determines whether a missing or undefined property value should be considered as null or not.\n     *\n     * If true, a missing JSON value will be added and set as null before deserialization.\n     * For serialization, undefined values will be set to null before serialization.\n     *\n     * ValueCheckingMode and PropertyConvertingMode determine whether an error will be thrown during\n     * serialization or deserialization.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._mapUndefinedToNull;\n    },\n    /**\n     * Determines whether a missing or undefined property value should be considered as null or not.\n     *\n     * If true, a missing JSON value will be added and set as null before deserialization.\n     * For serialization, undefined values will be set to null before serialization.\n     *\n     * The ValueCheckingMode and PropertyConvertingMode determine whether an error will be thrown during\n     * serialization or deserialization.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      this._mapUndefinedToNull = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"ignorePrimitiveChecks\", {\n    /**\n     * Determines whether primitive types should be checked.\n     * If true, it will be allowed to assign primitive to other primitive types.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._ignorePrimitiveChecks;\n    },\n    /**\n     * Determines whether primitive types should be checked.\n     * If true, it will be allowed to assign primitive to other primitive types.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      this._ignorePrimitiveChecks = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"propertyMatchingRule\", {\n    /**\n     * Determines the rule of how JSON properties shall be matched with class properties during deserialization.\n     *\n     * You may assign the following values:\n     * - PropertyMatchingRule.CASE_STRICT: JSON properties need to match exactly the names in the decorators\n     * - PropertyMatchingRule.CASE_INSENSITIVE: JSON properties need to match names in the decorators, but names they\n     * are not case sensitive\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._propertyMatchingRule;\n    },\n    /**\n     * Determines the rule of how JSON properties shall be matched with class properties during deserialization.\n     *\n     * You may assign the following values:\n     * - PropertyMatchingRule.CASE_STRICT: JSON properties need to match exactly the names in the decorators\n     * - PropertyMatchingRule.CASE_INSENSITIVE: JSON properties need to match names in the decorators, but names they\n     * are not case sensitive\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      if (value in PropertyMatchingRule) this._propertyMatchingRule = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"propertyConvertingMode\", {\n    /**\n     * Determines how nullable property types should be serialized and deserialized.\n     * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n     *\n     * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n     *\n     * The values should be used as follows:\n     * - MAP_NULLABLE: the mapper is applied, type is checked\n     * - IGNORE_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * not added to the result\n     * - PASS_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * added with its value to the result\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._propertyConvertingMode;\n    },\n    /**\n     * Determines how nullable property types should be serialized and deserialized.\n     * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n     *\n     * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n     *\n     * The values should be used as follows:\n     * - MAP_NULLABLE: the mapper is applied, type is checked\n     * - IGNORE_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * not added to the result\n     * - PASS_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * added with its value to the result\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      this._propertyConvertingMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"ignoreRequiredCheck\", {\n    /**\n     * @deprecated\n     */\n    get: function () {\n      return this.propertyConvertingMode === PropertyConvertingMode.IGNORE_NULLABLE;\n    },\n    /**\n     * @deprecated\n     */\n    set: function (value) {\n      this.propertyConvertingMode = value ? PropertyConvertingMode.IGNORE_NULLABLE : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"useDiscriminator\", {\n    /**\n     * Determines if discriminators should be used.\n     * If this option is set to true, all registered classes will be serialized with an additional discriminator\n     * property (default: \"$type\"), which has the key of the class (given in the @JsonObject decorator) as value.\n     * When deserializing an object containing the discriminator property, json2typescript will attempt to\n     * automatically instantiate the correct type (by comparing the value of the discriminator property with the\n     * registered classes).\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._useDiscriminator;\n    },\n    /**\n     * Determines if discriminators should be used.\n     * If this option is set to true, all registered classes will be serialized with an additional discriminator\n     * property (default: \"$type\"), which has the key of the class (given in the @JsonObject decorator) as value.\n     * When deserializing an object containing the discriminator property, json2typescript will attempt to\n     * automatically instantiate the correct type (by comparing the value of the discriminator property with the\n     * registered classes).\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      this._useDiscriminator = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"discriminatorPropertyName\", {\n    /**\n     * Defines the name of the discriminator property.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._discriminatorPropertyName;\n    },\n    /**\n     * Defines the name of the discriminator property.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      this._discriminatorPropertyName = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"classes\", {\n    /**\n     * Determines all classes which should use the lazy-loading or discriminator feature.\n     * Only classes provided here can be used with lazy-loading or the discriminator property.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._classes;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ////////////////////\n  // PUBLIC METHODS //\n  ////////////////////\n  /**\n   * Registers a list of classes to be used in the discriminator feature.\n   * After registering these classes, they may be used for the discriminator feature.\n   *\n   * @param classReferences the class references\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n  JsonConvert.prototype.registerClasses = function () {\n    var _this = this;\n    var classReferences = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      classReferences[_i] = arguments[_i];\n    }\n    classReferences.forEach(function (classReference) {\n      var key = classReference.prototype[Settings.CLASS_IDENTIFIER] || classReference.name;\n      if (key) {\n        _this.classes.set(key, classReference);\n      }\n    });\n  };\n  /**\n   * Unregisters a list of classes from the discriminator feature.\n   * After unregistering these classes, they cannot be used anymore for the discriminator feature.\n   *\n   * @param classReferences the class references\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n  JsonConvert.prototype.unregisterClasses = function () {\n    var _this = this;\n    var classReferences = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      classReferences[_i] = arguments[_i];\n    }\n    classReferences.forEach(function (classReference) {\n      var key = classReference.prototype[Settings.CLASS_IDENTIFIER] || classReference.name;\n      _this.classes.delete(key);\n    });\n  };\n  /**\n   * Unregisters all classes from discriminator feature.\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n  JsonConvert.prototype.unregisterAllClasses = function () {\n    this.classes.clear();\n  };\n  /**\n   * Tries to serialize a TypeScript object or array of objects to JSON using the mappings defined on\n   * the specified class reference. Note that if a class reference is provided, it will be used as\n   * the source of property mapping for serialization, even if the object or one of its elements is\n   * an instance of a different class with its own mappings.  Also, ONLY the properties from the\n   * class reference will be serialized - any additional properties on the object(s) will be silently\n   * ignored.\n   *\n   * @param data object or array of objects\n   * @param classReference the class reference which provides the property mappings to use\n   *\n   * @returns the JSON object\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n  JsonConvert.prototype.serialize = function (data, classReference) {\n    if (this.operationMode === OperationMode.DISABLE) {\n      return data;\n    }\n    // Call the appropriate method depending on the type\n    if (data instanceof Array) {\n      return this.serializeArray(data, classReference);\n    } else if (typeof data === \"object\") {\n      // careful: an array is an object in TypeScript!\n      return this.serializeObject(data, classReference);\n    } else {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter data in JsonConvert.serialize() is not in valid format (object or array).\" + \"\\n\");\n    }\n  };\n  /**\n   * Tries to serialize a TypeScript object to a JSON object using either the mappings on the\n   * provided class reference, if present, or on the provided object. Note that if a class\n   * reference is provided, it will be used as the source of property mapping for serialization,\n   * even if the object is itself an instance of a different class with its own mappings.\n   * Also, ONLY the properties from the class reference will be serialized - any additional\n   * properties on the object will be silently ignored.\n   *\n   * @param data object containing the values to be mapped to a JSON object, must be an\n   *             instance of a class with JSON mappings if no class reference is provided\n   * @param classReference optional class reference which provides the property mappings to use\n   *\n   * @returns the JSON object\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n  JsonConvert.prototype.serializeObject = function (data, classReference) {\n    if (this.operationMode === OperationMode.DISABLE) {\n      return data;\n    }\n    data = this.mapUndefinedToNull && data === undefined ? null : data;\n    // Check if the passed type is allowed\n    if (data === undefined) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instance in JsonConvert.serializeObject() is undefined. This is not a valid JSON format.\" + \"\\n\");\n    } else if (data === null) {\n      if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n        throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instance in JsonConvert.serializeObject() is null. You have specified to \" + \"disallow null values.\" + \"\\n\");\n      } else {\n        return data;\n      }\n    } else if (typeof data !== \"object\" || data instanceof Array) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instance in JsonConvert.serializeObject() is not of type object.\" + \"\\n\");\n    }\n    // Now serialize and return the plain object\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"----------\");\n      console.log(\"Receiving JavaScript instance:\");\n      console.log(data);\n    }\n    var jsonObject = {};\n    var instance;\n    if (!!classReference) {\n      instance = new classReference();\n    } else {\n      instance = data;\n    }\n    // Loop through all initialized class properties on the mapping instance\n    for (var _i = 0, _a = Object.keys(instance); _i < _a.length; _i++) {\n      var propertyKey = _a[_i];\n      try {\n        this.serializeObject_loopProperty(data, instance, propertyKey, jsonObject);\n      } catch (ex) {\n        if (this.operationMode === OperationMode.LOGGING) {\n          console.log(\"Failed to serialize property:\");\n          console.log(ex);\n          console.log(\"----------\");\n        }\n        throw ex;\n      }\n    }\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"Returning JSON object:\");\n      console.log(jsonObject);\n      console.log(\"----------\");\n    }\n    return jsonObject;\n  };\n  /**\n   * Tries to serialize a TypeScript array to a JSON array using either the mappings on the\n   * provided class reference, if present, or on the provided object. Note that if a class\n   * reference is provided, ALL objects in the array will be serialized using the mappings\n   * from that class reference, even if they're actually instances of a different class.\n   * Also, ONLY the properties from the class reference will be serialized - any additional\n   * properties on the objects will be silently ignored.\n   *\n   * @param dataArray array of objects containing the values to be mapped to a JSON object, which\n   *                  must be instances of classes with JSON mappings if no class reference is provided\n   * @param classReference optional class reference which provides the property mappings to use\n   *\n   * @returns the JSON array\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n  JsonConvert.prototype.serializeArray = function (dataArray, classReference) {\n    if (this.operationMode === OperationMode.DISABLE) {\n      return dataArray;\n    }\n    dataArray = this.mapUndefinedToNull && dataArray === undefined ? null : dataArray;\n    // Check if the passed type is allowed\n    if (dataArray === undefined) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instanceArray in JsonConvert.serializeArray() is undefined. This is not a valid JSON format.\" + \"\\n\");\n    } else if (dataArray === null) {\n      if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n        throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instanceArray in JsonConvert.serializeArray() is null. You have specified to \" + \"disallow null values.\" + \"\\n\");\n      } else {\n        return dataArray;\n      }\n    } else if (typeof dataArray !== \"object\" || dataArray instanceof Array === false) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instanceArray in JsonConvert.serializeArray() is not of type array.\" + \"\\n\");\n    }\n    // Now serialize and return the plain object\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"----------\");\n      console.log(\"Receiving JavaScript array:\");\n      console.log(dataArray);\n    }\n    var jsonArray = [];\n    // Loop through all array elements\n    for (var _i = 0, dataArray_1 = dataArray; _i < dataArray_1.length; _i++) {\n      var dataObject = dataArray_1[_i];\n      jsonArray.push(this.serializeObject(dataObject, classReference));\n    }\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"Returning JSON array:\");\n      console.log(jsonArray);\n      console.log(\"----------\");\n    }\n    return jsonArray;\n  };\n  /**\n   * Tries to deserialize given JSON to a TypeScript object or array of objects.\n   *\n   * @param json the JSON as object or array\n   * @param classReference the class reference\n   *\n   * @returns the deserialized data (TypeScript instance or array of TypeScript instances)\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n  JsonConvert.prototype.deserialize = function (json, classReference) {\n    if (classReference === void 0) {\n      classReference = null;\n    }\n    if (this.operationMode === OperationMode.DISABLE) {\n      return json;\n    }\n    // Call the appropriate method depending on the type\n    if (json instanceof Array) {\n      return this.deserializeArray(json, classReference);\n    } else if (typeof json === \"object\") {\n      // careful: an array is an object in TypeScript!\n      return this.deserializeObject(json, classReference);\n    } else {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter json in JsonConvert.deserialize() is not in valid JSON format (object or array).\" + \"\\n\");\n    }\n  };\n  /**\n   * Tries to deserialize a JSON object to a TypeScript object.\n   *\n   * @param jsonObject the JSON object\n   * @param classReference the class reference\n   *\n   * @returns the deserialized TypeScript instance\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n  JsonConvert.prototype.deserializeObject = function (jsonObject, classReference) {\n    if (classReference === void 0) {\n      classReference = null;\n    }\n    if (this.operationMode === OperationMode.DISABLE) {\n      return jsonObject;\n    }\n    var realClassReference = this.getRealClassReference(jsonObject, classReference);\n    jsonObject = this.mapUndefinedToNull && jsonObject === undefined ? null : jsonObject;\n    // Check if the passed type is allowed\n    if (jsonObject === undefined) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonObject in JsonConvert.deserializeObject() is undefined. This is not a valid JSON format.\" + \"\\n\");\n    } else if (jsonObject === null) {\n      if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n        throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonObject in JsonConvert.deserializeObject() is null. You have specified to \" + \"disallow null values.\" + \"\\n\");\n      } else {\n        return jsonObject;\n      }\n    } else if (typeof jsonObject !== \"object\" || jsonObject instanceof Array) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonObject in JsonConvert.deserializeObject() is not of type object.\" + \"\\n\");\n    }\n    // Now deserialize and return the instance\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"----------\");\n      console.log(\"Receiving JSON object:\");\n      console.log(jsonObject);\n    }\n    var instance = new realClassReference();\n    // Loop through all initialized class properties\n    for (var _i = 0, _a = Object.keys(instance); _i < _a.length; _i++) {\n      var propertyKey = _a[_i];\n      try {\n        this.deserializeObject_loopProperty(instance, propertyKey, jsonObject);\n      } catch (ex) {\n        if (this.operationMode === OperationMode.LOGGING) {\n          console.log(\"Failed to deserialize property:\");\n          console.log(ex);\n          console.log(\"----------\");\n        }\n        throw ex;\n      }\n    }\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"Returning CLASS instance:\");\n      console.log(instance);\n      console.log(\"----------\");\n    }\n    return instance;\n  };\n  /**\n   * Tries to deserialize a JSON array to a TypeScript array.\n   *\n   * @param jsonArray the JSON array\n   * @param classReference the object class\n   *\n   * @returns the deserialized array of TypeScript instances\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n  JsonConvert.prototype.deserializeArray = function (jsonArray, classReference) {\n    if (classReference === void 0) {\n      classReference = null;\n    }\n    if (this.operationMode === OperationMode.DISABLE) {\n      return jsonArray;\n    }\n    jsonArray = this.mapUndefinedToNull && jsonArray === undefined ? null : jsonArray;\n    // Check if the passed type is allowed\n    if (jsonArray === undefined) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonArray in JsonConvert.deserializeObject() is undefined. This is not a valid JSON format.\" + \"\\n\");\n    } else if (jsonArray === null) {\n      if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n        throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonArray in JsonConvert.deserializeObject() is null. You have specified to \" + \"disallow null values.\" + \"\\n\");\n      } else {\n        return jsonArray;\n      }\n    } else if (typeof jsonArray !== \"object\" || jsonArray instanceof Array === false) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonArray in JsonConvert.deserializeArray() is not of type array.\" + \"\\n\");\n    }\n    // Now deserialize and return the array\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"----------\");\n      console.log(\"Receiving JSON array:\");\n      console.log(jsonArray);\n    }\n    var array = [];\n    // Loop through all array elements\n    for (var _i = 0, jsonArray_1 = jsonArray; _i < jsonArray_1.length; _i++) {\n      var jsonObject = jsonArray_1[_i];\n      array.push(this.deserializeObject(jsonObject, classReference));\n    }\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"Returning array of CLASS instances:\");\n      console.log(array);\n      console.log(\"----------\");\n    }\n    return array;\n  };\n  /////////////////////\n  // PRIVATE METHODS //\n  /////////////////////\n  /**\n   * Returns the correct class reference for the provided JSON object.\n   * If the provided class reference is null, the class reference is retrieved from the class map using the discriminator property.\n   *\n   * @param jsonObject the JSON object\n   * @param classReference the class reference\n   * @throws throws an Error in case of failure\n   */\n  JsonConvert.prototype.getRealClassReference = function (jsonObject, classReference) {\n    var _a;\n    // First determine if the discriminator is used or not\n    if (this.useDiscriminator) {\n      // Check if we find the $type property. If not, throw an error.\n      if (jsonObject.hasOwnProperty(this.discriminatorPropertyName)) {\n        var discriminatorValue = (_a = jsonObject[this.discriminatorPropertyName]) !== null && _a !== void 0 ? _a : \"\";\n        var classReferenceNameFromMap = this.classes.get(discriminatorValue);\n        if (classReferenceNameFromMap !== undefined && classReferenceNameFromMap !== null) {\n          return classReferenceNameFromMap;\n        } else {\n          throw new Error(\"Fatal error in JsonConvert. \" + \"Discriminator value \\\"\" + discriminatorValue + \"\\\" could not be found in the registered classes. \" + \"Make sure you register the class using the method JsonConvert.registerClasses(\" + discriminatorValue + \")\" + \"\\n\");\n        }\n      } else {\n        throw new Error(\"Fatal error in JsonConvert. \" + \"Discriminator property \\\"\" + this.discriminatorPropertyName + \"\\\" is missing in JSON object.\" + \"\\n\");\n      }\n    } else {\n      // Make sure the class reference is given for if the discriminator is disabled\n      if (classReference === null) {\n        throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter classReference in JsonConvert.deserialize() is null. \" + \"This is only allowed if discriminator feature is enabled.\" + \"\\n\");\n      }\n      return classReference;\n    }\n  };\n  /**\n   * Tries to find the JSON mapping for a given class property from the given instance used for mapping,\n   * and finally assign the value from the given dataObject\n   *\n   * @param dataObject the object containing the value to be assigned\n   * @param instance the instance of the class used for mapping\n   * @param classPropertyName the property name\n   * @param json the JSON object\n   * @throws throws an Error in case of failure\n   */\n  JsonConvert.prototype.serializeObject_loopProperty = function (dataObject, instance, classPropertyName, json) {\n    var _this = this;\n    var _a, _b;\n    // Check if a JSON-object mapping is possible for a property\n    var mappingOptions = this.getClassPropertyMappingOptions(instance, classPropertyName);\n    if (mappingOptions === null) {\n      return;\n    }\n    // Get expected and real values\n    var jsonPropertyName = mappingOptions.jsonPropertyName;\n    var expectedJsonType = mappingOptions.expectedJsonType;\n    var convertingMode = (_a = this.propertyConvertingMode) !== null && _a !== void 0 ? _a : mappingOptions.convertingMode;\n    var customConverter = mappingOptions.customConverter;\n    var classInstancePropertyValue = dataObject[classPropertyName];\n    // Check if we have a nullable type\n    classInstancePropertyValue = this.mapUndefinedToNull && classInstancePropertyValue === undefined ? null : classInstancePropertyValue;\n    if (classInstancePropertyValue === undefined || classInstancePropertyValue === null) {\n      if (convertingMode === PropertyConvertingMode.IGNORE_NULLABLE) {\n        return;\n      }\n      if (convertingMode === PropertyConvertingMode.PASS_NULLABLE) {\n        json[jsonPropertyName] = classInstancePropertyValue;\n        return;\n      }\n    }\n    // Map the property\n    try {\n      json[jsonPropertyName] = customConverter !== null ? customConverter.serialize(classInstancePropertyValue) : this.convertProperty(expectedJsonType, classInstancePropertyValue, convertingMode, true);\n      var classConstructorName_1 = (_b = dataObject === null || dataObject === void 0 ? void 0 : dataObject.constructor) === null || _b === void 0 ? void 0 : _b.name;\n      if (this._useDiscriminator && json instanceof Object) {\n        this.classes.forEach(function (classDataObject, key) {\n          if (classDataObject.name === classConstructorName_1) {\n            json[_this._discriminatorPropertyName] = key;\n          }\n        });\n      }\n    } catch (e) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Failed to map the JavaScript instance of class \\\"\" + instance[Settings.CLASS_IDENTIFIER] + \"\\\" to JSON because of a type error.\\n\\n\" + \"\\tClass property: \\n\\t\\t\" + classPropertyName + \"\\n\\n\" + \"\\tClass property value: \\n\\t\\t\" + classInstancePropertyValue + \"\\n\\n\" + \"\\tExpected type: \\n\\t\\t\" + this.getExpectedType(expectedJsonType) + \"\\n\\n\" + \"\\tRuntime type: \\n\\t\\t\" + this.getTrueType(classInstancePropertyValue) + \"\\n\\n\" + \"\\tJSON property: \\n\\t\\t\" + jsonPropertyName + \"\\n\\n\" + e.message + \"\\n\");\n    }\n  };\n  /**\n   * Tries to find the JSON mapping for a given class property and finally assign the value.\n   *\n   * @param instance the instance of the class\n   * @param classPropertyName the property name\n   * @param json the JSON object\n   *\n   * @throws throws an Error in case of failure\n   */\n  JsonConvert.prototype.deserializeObject_loopProperty = function (instance, classPropertyName, json) {\n    var _a;\n    var mappingOptions = this.getClassPropertyMappingOptions(instance, classPropertyName);\n    if (mappingOptions === null) {\n      return;\n    }\n    // Get expected and real values\n    var jsonPropertyName = mappingOptions.jsonPropertyName;\n    var expectedJsonType = mappingOptions.expectedJsonType;\n    var convertingMode = (_a = this.propertyConvertingMode) !== null && _a !== void 0 ? _a : mappingOptions.convertingMode;\n    var customConverter = mappingOptions.customConverter;\n    var jsonValue = undefined;\n    try {\n      jsonValue = this.getObjectValue(json, jsonPropertyName);\n    } catch (_b) {}\n    // Check if we have a nullable type\n    jsonValue = this.mapUndefinedToNull && jsonValue === undefined ? null : jsonValue;\n    if (jsonValue === undefined || jsonValue === null) {\n      if (convertingMode === PropertyConvertingMode.IGNORE_NULLABLE) {\n        return;\n      }\n      if (convertingMode === PropertyConvertingMode.PASS_NULLABLE) {\n        instance[classPropertyName] = jsonValue;\n        return;\n      }\n    }\n    // Map the property\n    try {\n      var classConstructorName = jsonValue instanceof Object ? jsonValue[this.discriminatorPropertyName] : null;\n      if (this._useDiscriminator && this.classes.has(classConstructorName)) {\n        expectedJsonType = this.classes.get(classConstructorName);\n      }\n      instance[classPropertyName] = customConverter !== null ? customConverter.deserialize(jsonValue) : this.convertProperty(expectedJsonType, jsonValue, convertingMode);\n    } catch (e) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Failed to map the JSON object to the class \\\"\" + instance[Settings.CLASS_IDENTIFIER] + \"\\\" because of a type error.\\n\\n\" + \"\\tClass property: \\n\\t\\t\" + classPropertyName + \"\\n\\n\" + \"\\tExpected type: \\n\\t\\t\" + this.getExpectedType(expectedJsonType) + \"\\n\\n\" + \"\\tJSON property: \\n\\t\\t\" + jsonPropertyName + \"\\n\\n\" + \"\\tJSON type: \\n\\t\\t\" + this.getJsonType(jsonValue) + \"\\n\\n\" + \"\\tJSON value: \\n\\t\\t\" + JSON.stringify(jsonValue) + \"\\n\\n\" + e.message + \"\\n\");\n    }\n  };\n  ////////////////////\n  // HELPER METHODS //\n  ////////////////////\n  /**\n   * Gets the mapping options of a given class property.\n   *\n   * @param instance any class instance\n   * @param {string} propertyName any property name\n   *\n   * @returns {MappingOptions|null}\n   */\n  JsonConvert.prototype.getClassPropertyMappingOptions = function (instance, propertyName) {\n    var mappings = instance[Settings.MAPPING_PROPERTY];\n    // Check if mapping is defined\n    if (typeof mappings === \"undefined\") return null;\n    /* Find mapping by iterating up the prototype chain to find a matching mapping, rather than\n     * just searching by property name. */\n    var prototype = Object.getPrototypeOf(instance);\n    /* According to documentation, we'll hit null when we've iterated all the way up to the base\n     * Object, but check for undefined as well in case prototype has been manually set to\n     * undefined. Note that javascript detects circular prototype references and will cause a\n     * TypeError, so no need to check for self, the prototype chain will eventually terminate. */\n    while (prototype !== null && prototype !== undefined) {\n      var classIdentifier = prototype[Settings.CLASS_IDENTIFIER];\n      if (!!classIdentifier) {\n        var mappingName = classIdentifier + \".\" + propertyName;\n        if (typeof mappings[mappingName] !== \"undefined\") {\n          return mappings[mappingName];\n        }\n      }\n      prototype = Object.getPrototypeOf(prototype);\n    }\n    return null;\n  };\n  /**\n   * Compares the type of a given value with an internal expected json type.\n   * Either returns the resulting value or throws an exception.\n   *\n   * @param expectedType the expected type for the property\n   * @param value the property value to verify\n   * @param convertingMode the converting mode for this property\n   * @param serialize optional param (default: false), if given, we are in serialization mode\n   *\n   * @returns returns the resulted mapped property\n   *\n   * @throws an error in case of failure\n   */\n  JsonConvert.prototype.convertProperty = function (expectedType, value, convertingMode, serialize) {\n    ////////////////////////////\n    // Prior checks and setup //\n    ////////////////////////////\n    // Return the value immediately if we don't care about the type\n    if (expectedType === undefined || expectedType === Any || expectedType === null || expectedType === Object) {\n      return value;\n    }\n    // Check if we have a nullable type\n    value = this.mapUndefinedToNull && value === undefined ? null : value;\n    if (value === undefined || value === null) {\n      if (convertingMode === PropertyConvertingMode.IGNORE_NULLABLE) {\n        return undefined;\n      }\n      if (convertingMode === PropertyConvertingMode.PASS_NULLABLE) {\n        return value;\n      }\n    }\n    var expectedDimension = \"1\";\n    if (expectedType instanceof Array) {\n      expectedDimension = \"2\";\n    }\n    var valueDimension = \"1or2\";\n    if (value instanceof Array) {\n      valueDimension = \"2\";\n    } else if (!(value instanceof Object)) {\n      valueDimension = \"1\";\n    }\n    if (expectedDimension === \"1\" && valueDimension === \"2\") {\n      throw new Error(\"\\tReason: Expected a non-array type, but given value is an array.\");\n    }\n    if (expectedDimension === \"2\" && valueDimension === \"1\") {\n      // Allow to use null in the special case\n      if (value === null && this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL) {\n        return null;\n      } else if (value === null) {\n        throw new Error(\"\\tReason: Expected an array, but given value is null.\");\n      }\n      throw new Error(\"\\tReason: Expected an array, but given value is a primitive type.\");\n    }\n    //////////////////\n    // Check values //\n    //////////////////\n    if (expectedDimension === \"2\" && (valueDimension === \"2\" || valueDimension === \"1or2\")) {\n      // Return an empty array if we have an empty array or object as value\n      if (value.length === 0 || Object.keys(value).length === 0) {\n        return [];\n      }\n      // Return the value if we don't care about the array type\n      if (expectedType.length === 0) {\n        return value;\n      }\n      // Copy the expectedJsonType array so we don't change the class-level mapping based on the value of this property\n      var jsonType = expectedType.slice(0);\n      var array = [];\n      if (valueDimension === \"2\") {\n        // Loop through the data. Both type and value are at least of length 1\n        var autofillType = jsonType.length < value.length;\n        for (var i = 0; i < value.length; i++) {\n          if (autofillType && i >= jsonType.length) {\n            jsonType[i] = jsonType[i - 1];\n          }\n          array[i] = this.convertProperty(jsonType[i], value[i], this.propertyConvertingMode || PropertyConvertingMode.MAP_NULLABLE, serialize);\n        }\n        return array;\n      } else {\n        // Loop through the data. Both type and value are at least of length 1\n        var autofillType = jsonType.length < Object.keys(value).length;\n        var i = 0;\n        for (var key in value) {\n          if (autofillType && i >= jsonType.length) {\n            jsonType[i] = jsonType[i - 1];\n          }\n          array[key] = this.convertProperty(jsonType[i], value[key], this.propertyConvertingMode || PropertyConvertingMode.MAP_NULLABLE, serialize);\n          i++;\n        }\n        return array;\n      }\n    } else if (expectedDimension === \"1\" && (valueDimension === \"1\" || valueDimension === \"1or2\")) {\n      // Check if objects match\n      if ((expectedType instanceof Object && [String, Number, Boolean].includes(expectedType) === false || typeof expectedType === \"string\") && value instanceof Object) {\n        // If the expected type is a string (means: lazy-loading), get the real type from the registered classes\n        if (typeof expectedType === \"string\") {\n          var realExpectedType = this.classes.get(expectedType);\n          if (!realExpectedType) {\n            throw new Error(\"\\tReason: Given expected type \\\"\" + expectedType + \"\\\" not registered with JsonConvert.registerClasses().\");\n          }\n          expectedType = realExpectedType;\n        }\n        if (expectedType.prototype.hasOwnProperty(Settings.CLASS_IDENTIFIER)) {\n          return serialize ? this.serializeObject(value, expectedType) : this.deserializeObject(value, expectedType);\n        } else {\n          return value;\n        }\n      } else {\n        // Check for null values\n        if (value === null) {\n          if (expectedType === String || expectedType === Number || expectedType === Boolean) {\n            if (this.valueCheckingMode === ValueCheckingMode.ALLOW_NULL) {\n              return null;\n            } else {\n              throw new Error(\"\\tReason: Given value null does not match the expected primitive type.\");\n            }\n          } else {\n            if (this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL) {\n              return null;\n            } else {\n              throw new Error(\"\\tReason: Given value null does not match the expected object type.\");\n            }\n          }\n        }\n        // Check for primitive matches\n        if (expectedType === String && typeof value === \"string\" || expectedType === Number && typeof value === \"number\" || expectedType === Boolean && typeof value === \"boolean\") {\n          return value;\n        } else {\n          if (this.ignorePrimitiveChecks && [\"string\", \"number\", \"boolean\"].includes(typeof value)) {\n            return value;\n          }\n          throw new Error(\"\\tReason: Given value type does not match the expected primitive type.\");\n        }\n      }\n    }\n    // All other attempts are fatal\n    throw new Error(\"\\tReason: Mapping failed because of an unknown error.\");\n  };\n  /**\n   * Gets the value of an object for a given value.\n   * If the object does not have the specific key, an Error is thrown.\n   *\n   * @param data\n   * @param key\n   *\n   * @returns returns the value\n   *\n   * @throws an Error in case of the key was not found in the object\n   */\n  JsonConvert.prototype.getObjectValue = function (data, key) {\n    // If we do not care about the case of the key, ad\n    if (this.propertyMatchingRule === PropertyMatchingRule.CASE_INSENSITIVE) {\n      // Create a mapping of the keys: keys[lowercase]=normalcase\n      var keyMapping = Object.keys(data).reduce(function (keys, key) {\n        keys[key.toLowerCase()] = key;\n        return keys;\n      }, {});\n      // Define the new key\n      key = keyMapping[key.toLowerCase()];\n    }\n    // Throw an error if the key is not in the object\n    if (key in data === false) {\n      throw new Error();\n    }\n    return data[key];\n  };\n  ///////////////////////////\n  // JSON2TYPESCRIPT TYPES //\n  ///////////////////////////\n  /**\n   * Returns a string representation of the expected json type.\n   *\n   * @param expectedJsonType the expected type given from the decorator\n   *\n   * @returns {string} the string representation\n   */\n  JsonConvert.prototype.getExpectedType = function (expectedJsonType) {\n    var type = \"\";\n    if (expectedJsonType instanceof Array) {\n      type = \"[\";\n      for (var i = 0; i < expectedJsonType.length; i++) {\n        if (i > 0) type += \",\";\n        type += this.getExpectedType(expectedJsonType[i]);\n      }\n      type += \"]\";\n      return type;\n    } else {\n      if (expectedJsonType === Any || expectedJsonType === null || expectedJsonType === Object) {\n        return \"any\";\n      } else if (expectedJsonType === String || expectedJsonType === Boolean || expectedJsonType === Number) {\n        return new expectedJsonType().constructor.name.toLowerCase();\n      } else if (typeof expectedJsonType === \"function\") {\n        return new expectedJsonType().constructor.name;\n      } else if (typeof expectedJsonType === \"string\") {\n        return expectedJsonType;\n      } else if (expectedJsonType === undefined) {\n        return \"undefined\";\n      } else {\n        return \"?????\";\n      }\n    }\n  };\n  /**\n   * Returns a string representation of the JSON value type.\n   *\n   * @param jsonValue the JSON value\n   *\n   * @returns {string} the string representation\n   */\n  JsonConvert.prototype.getJsonType = function (jsonValue) {\n    if (jsonValue === null) return \"null\";\n    var type = \"\";\n    if (jsonValue instanceof Array) {\n      type = \"[\";\n      for (var i = 0; i < jsonValue.length; i++) {\n        if (i > 0) type += \",\";\n        type += this.getJsonType(jsonValue[i]);\n      }\n      type += \"]\";\n      return type;\n    } else {\n      return typeof jsonValue;\n    }\n  };\n  /**\n   * Returns a string representation of the true TypeScript type.\n   *\n   * @param trueValue the true value\n   *\n   * @returns {string} the string representation\n   */\n  JsonConvert.prototype.getTrueType = function (trueValue) {\n    return typeof trueValue;\n  };\n  return JsonConvert;\n}();\nexport { JsonConvert };\n//# sourceMappingURL=json-convert.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}